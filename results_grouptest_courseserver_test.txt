============================= test session starts ==============================
platform linux -- Python 3.7.3, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 -- /usr/bin/python3
cachedir: .pytest_cache
hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase('/tmp_amd/kamen/export/kamen/3/cs1531/automark/tempstore/.hypothesis/examples')
rootdir: /tmp_amd/kamen/export/kamen/3/cs1531/automark/tempstore, configfile: pytest.ini
plugins: forked-1.3.0, xdist-2.2.1, hypothesis-6.1.1, timeout-1.4.2
collecting ... collected 183 items

http_tests/admin_http_test.py::test_http_admin_user_remove_u_id_does_not_exist FAILED [  0%]
http_tests/admin_http_test.py::test_http_admin_user_remove_auth_not_owner FAILED [  1%]
http_tests/admin_http_test.py::test_http_admin_user_remove_auth_only_owner FAILED [  1%]
http_tests/admin_http_test.py::test_http_admin_user_remove_successful_removed PASSED [  2%]
http_tests/admin_http_test.py::test_http_admin_userpermission_u_id_does_not_exist FAILED [  2%]
http_tests/admin_http_test.py::test_http_admin_userpermission_permission_id_not_valid FAILED [  3%]
http_tests/admin_http_test.py::test_http_admin_userpermission_auth_not_owner FAILED [  3%]
http_tests/admin_http_test.py::test_http_admin_userpermission_member_to_owner_permission PASSED [  4%]
http_tests/admin_http_test.py::test_http_admin_userpermission_owner_to_member_permission PASSED [  4%]
http_tests/admin_http_test.py::test_http_admin_user_remove_u_id_does_not_exist FAILED [  4%]
http_tests/admin_http_test.py::test_http_admin_user_remove_auth_not_owner FAILED [  4%]
http_tests/admin_http_test.py::test_http_admin_user_remove_auth_only_owner FAILED [  4%]
http_tests/admin_http_test.py::test_http_admin_user_remove_successful_removed PASSED [  4%]
http_tests/admin_http_test.py::test_http_admin_userpermission_u_id_does_not_exist FAILED [  4%]
http_tests/admin_http_test.py::test_http_admin_userpermission_permission_id_not_valid FAILED [  4%]
http_tests/admin_http_test.py::test_http_admin_userpermission_auth_not_owner FAILED [  4%]
http_tests/admin_http_test.py::test_http_admin_userpermission_member_to_owner_permission PASSED [  4%]
http_tests/admin_http_test.py::test_http_admin_userpermission_owner_to_member_permission PASSED [  4%]
http_tests/auth_http_test.py::test_http_auth_register_working PASSED     [  5%]
http_tests/auth_http_test.py::test_http_auth_register_already_registered_email FAILED [  6%]
http_tests/auth_http_test.py::test_http_auth_register_invalid_email FAILED [  6%]
http_tests/auth_http_test.py::test_http_auth_register_short_first FAILED [  7%]
http_tests/auth_http_test.py::test_http_auth_register_short_last FAILED  [  7%]
http_tests/auth_http_test.py::test_http_auth_register_long_first FAILED  [  8%]
http_tests/auth_http_test.py::test_http_auth_register_long_last FAILED   [  8%]
http_tests/auth_http_test.py::test_http_auth_login_working PASSED        [  9%]
http_tests/auth_http_test.py::test_http_auth_login_invalid_email FAILED  [  9%]
http_tests/auth_http_test.py::test_http_auth_login_unregistered_email FAILED [ 10%]
http_tests/auth_http_test.py::test_http_auth_login_incorrect_password FAILED [ 10%]
http_tests/auth_http_test.py::test_http_logout_working PASSED            [ 11%]
http_tests/auth_http_test.py::test_http_logout_invalid_token_key FAILED  [ 12%]
http_tests/auth_http_test.py::test_http_logout_invalid_token_value FAILED [ 12%]
http_tests/auth_http_test.py::test_http_logout_invalid_token_type FAILED [ 13%]
http_tests/auth_http_test.py::test_http_logout_nonexistant_user FAILED   [ 13%]
http_tests/auth_http_test.py::test_http_passwordreset_request_working PASSED [ 14%]
http_tests/auth_http_test.py::test_http_passwordreset_request_invalid_email FAILED [ 14%]
http_tests/auth_http_test.py::test_http_passwordreset_reset_invalid_code FAILED [ 15%]
http_tests/auth_http_test.py::test_http_passwordreset_reset_invalid_password FAILED [ 15%]
http_tests/channel_http_test.py::testjoin_invalid_channelID FAILED       [ 16%]
http_tests/channel_http_test.py::testjoin_invalid_tokenn FAILED          [ 16%]
http_tests/channel_http_test.py::testjoin_joined_already FAILED          [ 17%]
http_tests/channel_http_test.py::testjoin_private_channel FAILED         [ 18%]
http_tests/channel_http_test.py::testjoin_already_joined FAILED          [ 18%]
http_tests/channel_http_test.py::testjoin_valid_case FAILED              [ 19%]
http_tests/channel_http_test.py::testaddowner_invalid_tokenn FAILED      [ 19%]
http_tests/channel_http_test.py::testaddowner_invalid_uID FAILED         [ 20%]
http_tests/channel_http_test.py::testaddowner_invalid_channelID FAILED   [ 20%]
http_tests/channel_http_test.py::testaddowner_already_owner FAILED       [ 21%]
http_tests/channel_http_test.py::testaddowner_unauthorised_token FAILED  [ 21%]
http_tests/channel_http_test.py::testaddowner_not_in_channel FAILED      [ 22%]
http_tests/channel_http_test.py::testaddowner_valid_case PASSED          [ 22%]
http_tests/channel_http_test.py::test_http_channel_removeowner_working PASSED [ 23%]
http_tests/channel_http_test.py::test_http_channel_removeowner_invalid_user FAILED [ 24%]
http_tests/channel_http_test.py::test_http_channel_removeowner_invalid_channel FAILED [ 24%]
http_tests/channel_http_test.py::test_http_channel_removeowner_only_owner FAILED [ 25%]
http_tests/channel_http_test.py::test_http_channel_removeowner_not_owner FAILED [ 25%]
http_tests/channel_http_test.py::test_http_channel_removeowner_invalid_token FAILED [ 26%]
http_tests/channel_http_test.py::test_http_channel_leave_working PASSED  [ 26%]
http_tests/channel_http_test.py::test_http_channel_leave_channel_valid FAILED [ 27%]
http_tests/channel_http_test.py::test_http_channel_leave_user_valid FAILED [ 27%]
http_tests/channel_http_test.py::test_http_channel_messages_working FAILED [ 28%]
http_tests/channel_http_test.py::test_http_channel_messages_invalid_channel FAILED [ 28%]
http_tests/channel_http_test.py::test_http_channel_messages_startgreater FAILED [ 29%]
http_tests/channel_http_test.py::test_http_channel_messages_not_authorised FAILED [ 30%]
http_tests/channel_http_test.py::test_http_channel_messages_endnegativeone PASSED [ 30%]
http_tests/channels_http_test.py::test_http_channels_create_working FAILED [ 31%]
http_tests/channels_http_test.py::test_http_channels_create_multiple FAILED [ 31%]
http_tests/channels_http_test.py::test_http_channels_create_invalid_token FAILED [ 32%]
http_tests/channels_http_test.py::test_http_channels_create_longer_than_twenty_char FAILED [ 32%]
http_tests/channels_http_test.py::test_http_channels_list_working FAILED [ 33%]
http_tests/channels_http_test.py::test_http_channels_list_invalid_user FAILED [ 33%]
http_tests/channels_http_test.py::test_http_channels_listall_working PASSED [ 34%]
http_tests/channels_http_test.py::test_http_channels_listall_invalid_user FAILED [ 34%]
http_tests/dm_http_test.py::test_http_dm_create_working FAILED           [ 35%]
http_tests/dm_http_test.py::test_http_dm_create_invalid_user FAILED      [ 36%]
http_tests/dm_http_test.py::test_http_dm_create_invalid_token FAILED     [ 36%]
http_tests/dm_http_test.py::test_http_dm_invite_working FAILED           [ 37%]
http_tests/dm_http_test.py::test_http_dm_invite_invalid_dmid FAILED      [ 37%]
http_tests/dm_http_test.py::test_http_dm_invite_invalid_uid FAILED       [ 38%]
http_tests/dm_http_test.py::test_http_dm_inviter_not_in_dm FAILED        [ 38%]
http_tests/dm_http_test.py::test_http_dm_list_working FAILED             [ 39%]
http_tests/dm_http_test.py::test_http_dm_list_invalid_token FAILED       [ 39%]
http_tests/dm_http_test.py::test_http_dm_leave_working PASSED            [ 40%]
http_tests/dm_http_test.py::test_http_dm_leave_invalid_dm FAILED         [ 40%]
http_tests/dm_http_test.py::test_http_dm_leave_unauthorized_user FAILED  [ 41%]
http_tests/dm_http_test.py::test_http_dm_leave_invalid_token FAILED      [ 42%]
http_tests/dm_http_test.py::test_http_dm_remove_working PASSED           [ 42%]
http_tests/dm_http_test.py::test_http_dm_remove_invalid_id FAILED        [ 43%]
http_tests/dm_http_test.py::test_http_dm_remove_not_owner FAILED         [ 43%]
http_tests/dm_http_test.py::test_http_dm_remove_invalid_token FAILED     [ 44%]
http_tests/dm_http_test.py::test_http_dm_message_working PASSED          [ 44%]
http_tests/dm_http_test.py::test_http_dm_message_invalid_user FAILED     [ 45%]
http_tests/dm_http_test.py::test_http_dm_message_invalid_dm FAILED       [ 45%]
http_tests/dm_http_test.py::test_http_dm_message_unauthorised_user FAILED [ 46%]
http_tests/dm_http_test.py::test_http_dm_message_startgreater FAILED     [ 46%]
http_tests/dm_http_test.py::test_http_dm_message_endnegativeone PASSED   [ 47%]
http_tests/dm_http_test.py::test_http_dm_details_dm_does_not_exist FAILED [ 48%]
http_tests/dm_http_test.py::test_http_dm_details_user_not_member_of_dm FAILED [ 48%]
http_tests/dm_http_test.py::test_http_dm_details_valid PASSED            [ 49%]
http_tests/echo_http_test.py::test_echo FAILED                           [ 49%]
http_tests/message_http_test.py::testsend_empty_message FAILED           [ 50%]
http_tests/message_http_test.py::testsend_invalid_long_msg FAILED        [ 50%]
http_tests/message_http_test.py::testsend_invalid_token FAILED           [ 51%]
http_tests/message_http_test.py::testsend_invalid_channel FAILED         [ 51%]
http_tests/message_http_test.py::testsend_sent_not_in_channel FAILED     [ 52%]
http_tests/message_http_test.py::testsend_valid_case FAILED              [ 53%]
http_tests/message_http_test.py::testedit_invalid_long_msg FAILED        [ 53%]
http_tests/message_http_test.py::testedit_invalid_token FAILED           [ 54%]
http_tests/message_http_test.py::testedit_invalid_mID FAILED             [ 54%]
http_tests/message_http_test.py::testedit_not_authorised FAILED          [ 55%]
http_tests/message_http_test.py::testedit_valid_case FAILED              [ 55%]
http_tests/message_http_test.py::testedit_comprehensive_valid FAILED     [ 56%]
http_tests/message_http_test.py::testremove_invalid_token_id FAILED      [ 56%]
http_tests/message_http_test.py::testremove_invalid_mID FAILED           [ 57%]
http_tests/message_http_test.py::testremove_empty FAILED                 [ 57%]
http_tests/message_http_test.py::testremove_unauthorised FAILED          [ 58%]
http_tests/message_http_test.py::testeremove_valid PASSED                [ 59%]
http_tests/message_http_test.py::testremove_comprehensive_valid PASSED   [ 59%]
http_tests/message_http_test.py::testsenddm_invalid_empty_message FAILED [ 60%]
http_tests/message_http_test.py::testsenddm_invalid_long_msg FAILED      [ 60%]
http_tests/message_http_test.py::testsenddm_invalid_token_ID FAILED      [ 61%]
http_tests/message_http_test.py::testsenddm_invalid_dmID FAILED          [ 61%]
http_tests/message_http_test.py::testsenddm_unauthorised_user FAILED     [ 62%]
http_tests/message_http_test.py::testsenddm_valid_case FAILED            [ 62%]
http_tests/message_http_test.py::test_http_message_share_not_member_of_channel_sharing_to FAILED [ 63%]
http_tests/message_http_test.py::test_http_message_share_not_member_of_dm_sharing_to FAILED [ 63%]
http_tests/message_http_test.py::test_http_message_share_Optional_message_channel PASSED [ 64%]
http_tests/message_http_test.py::test_http_message_share_no_optional_message PASSED [ 65%]
http_tests/message_http_test.py::test_http_message_share_optional_message_dm PASSED [ 65%]
http_tests/message_http_test.py::test_http_message_share_no_optional_message_dm PASSED [ 66%]
http_tests/message_http_test.py::testsendlater_too_long FAILED           [ 66%]
http_tests/message_http_test.py::testsendlater_token_fail FAILED         [ 67%]
http_tests/message_http_test.py::testsendlater_invalid_channel_id FAILED [ 67%]
http_tests/message_http_test.py::testsendlater_empty_msg FAILED          [ 68%]
http_tests/message_http_test.py::testsendlater_user_not_in_channel FAILED [ 68%]
http_tests/message_http_test.py::testsendlater_past_time FAILED          [ 69%]
http_tests/message_http_test.py::testsendlater_valid PASSED              [ 69%]
http_tests/message_http_test.py::testsendlaterdm_long_msg FAILED         [ 70%]
http_tests/message_http_test.py::testsendlaterdm_wrong_token FAILED      [ 71%]
http_tests/message_http_test.py::testsendlaterdm_wrong_dm_ID FAILED      [ 71%]
http_tests/message_http_test.py::testsendlaterdm_empty_msg FAILED        [ 72%]
http_tests/message_http_test.py::testsendlaterdm_user_not_found FAILED   [ 72%]
http_tests/message_http_test.py::testsendlaterdm_past_time FAILED        [ 73%]
http_tests/message_http_test.py::testsendlaterdm_valid PASSED            [ 73%]
http_tests/message_http_test.py::testreact_reacted_already FAILED        [ 74%]
http_tests/message_http_test.py::testreact_dm_valid PASSED               [ 74%]
http_tests/message_http_test.py::testunreact_unreacted_message FAILED    [ 75%]
http_tests/message_http_test.py::testunreact_valid_dm PASSED             [ 75%]
http_tests/message_http_test.py::testpin_pinned_already FAILED           [ 76%]
http_tests/message_http_test.py::testpin_dm_valid PASSED                 [ 77%]
http_tests/message_http_test.py::testunpin_unpinned_already FAILED       [ 77%]
http_tests/message_http_test.py::testunpin_dm_valid PASSED               [ 78%]
http_tests/notifications_http_test.py::test_http_notifications_working PASSED [ 78%]
http_tests/notifications_http_test.py::test_http_notifications_invalid_token FAILED [ 79%]
http_tests/other_http_test.py::test_http_clear_working PASSED            [ 79%]
http_tests/other_http_test.py::test_http_clear_channel PASSED            [ 80%]
http_tests/other_http_test.py::test_http_clear_dm FAILED                 [ 80%]
http_tests/other_http_test.py::test_search_working FAILED                [ 81%]
http_tests/other_http_test.py::test_search_invalid_token FAILED          [ 81%]
http_tests/standup_http_test.py::test_http_standup_working PASSED        [ 82%]
http_tests/standup_http_test.py::test_http_standup_invalid FAILED        [ 83%]
http_tests/standup_http_test.py::test_http_standup_active_working PASSED [ 83%]
http_tests/standup_http_test.py::test_http_standup_active_invalid FAILED [ 84%]
http_tests/standup_http_test.py::test_http_standup_send_working PASSED   [ 84%]
http_tests/standup_http_test.py::test_http_standup_send_invalid FAILED   [ 85%]
http_tests/user_http_test.py::test_http_user_profile_working FAILED      [ 85%]
http_tests/user_http_test.py::test_http_user_profile_v2_nonexistant_user FAILED [ 86%]
http_tests/user_http_test.py::test_user_profile_setname_working FAILED   [ 86%]
http_tests/user_http_test.py::test_http_user_profile_setname_short_first FAILED [ 87%]
http_tests/user_http_test.py::test_http_user_profile_setname_short_last FAILED [ 87%]
http_tests/user_http_test.py::test_http_user_profile_setname_long_first FAILED [ 88%]
http_tests/user_http_test.py::test_http_user_profile_setname_long_last FAILED [ 89%]
http_tests/user_http_test.py::test_http_user_profile_setemail_working FAILED [ 89%]
http_tests/user_http_test.py::test_http_user_profile_setemail_invalid_email FAILED [ 90%]
http_tests/user_http_test.py::test_http_user_profile_setemail_email_taken FAILED [ 90%]
http_tests/user_http_test.py::test_http_user_profile_sethandle_working FAILED [ 91%]
http_tests/user_http_test.py::test_http_user_profile_sethandle_short_handle FAILED [ 91%]
http_tests/user_http_test.py::test_http_user_profile_sethandle_long_handle FAILED [ 92%]
http_tests/user_http_test.py::test_http_user_profile_sethandle_handle_taken FAILED [ 92%]
http_tests/user_http_test.py::test_http_users_all_working FAILED         [ 93%]
http_tests/user_http_test.py::test_http_user_stats_working FAILED        [ 93%]
http_tests/user_http_test.py::test_http_users_stats_working FAILED       [ 94%]
http_tests/user_http_test.py::test_http_uploadPhoto_working PASSED       [ 95%]

=================================== FAILURES ===================================
_______________ test_http_admin_user_remove_u_id_does_not_exist ________________

    def test_http_admin_user_remove_u_id_does_not_exist():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
        # ----------------------------
        #chec admin user remove
        funcURL = "admin/user/remove/v1"
        inputData ={
            "token": userR['token'],
            "u_id": 3
        }
        adminUserRemove = requests.delete(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>3 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________ test_http_admin_user_remove_auth_not_owner __________________

    def test_http_admin_user_remove_auth_not_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------------
        #check admin user remove
        funcURL = "admin/user/remove/v1"
        inputData ={
            "token": user2R['token'],
            "u_id": user3R['auth_user_id']
        }
        adminUserRemove = requests.delete(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Only owners can remove members</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________ test_http_admin_user_remove_auth_only_owner __________________

    def test_http_admin_user_remove_auth_only_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        #check admin user remove
        funcURL = "admin/user/remove/v1"
        inputData ={
            "token": userR['token'],
            "u_id": userR['auth_user_id']
        }
        adminUserRemove = requests.delete(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Cannot remove last owner</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________ test_http_admin_userpermission_u_id_does_not_exist ______________

    def test_http_admin_userpermission_u_id_does_not_exist():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmai.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
        # ----------------------------
        #chec admin user permission
        funcURL = "admin/userpermission/change/v1"
        inputData ={
            "token": userR['token'],
            "u_id": 3,
            "permission_id": 1
        }
        adminUserPermission = requests.post(config.url + funcURL, json=inputData)
>       adminUserPermissionR = json.loads(adminUserPermission.text)

http_tests/admin_http_test.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>3 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________ test_http_admin_userpermission_permission_id_not_valid ____________

    def test_http_admin_userpermission_permission_id_not_valid():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmai.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        #check admin user permission
        funcURL = "admin/userpermission/change/v1"
        inputData ={
            "token": userR['token'],
            "u_id": user2R['auth_user_id'],
            "permission_id": 5
        }
        adminUserPermission = requests.post(config.url + funcURL, json=inputData)
>       adminUserPermissionR = json.loads(adminUserPermission.text)

http_tests/admin_http_test.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Invalid permission ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________ test_http_admin_userpermission_auth_not_owner _________________

    def test_http_admin_userpermission_auth_not_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------------
        #check admin user rpermssion
        funcURL = "admin/userpermission/change/v1"
        inputData ={
            "token": user2R['token'],
            "u_id": user3R['auth_user_id'],
            "permission_id": 1
    
        }
        adminUserRemove = requests.post(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Only owners can modify permissions</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________ test_http_admin_user_remove_u_id_does_not_exist ________________

    def test_http_admin_user_remove_u_id_does_not_exist():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
        # ----------------------------
        #chec admin user remove
        funcURL = "admin/user/remove/v1"
        inputData ={
            "token": userR['token'],
            "u_id": 3
        }
        adminUserRemove = requests.delete(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>3 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________ test_http_admin_user_remove_auth_not_owner __________________

    def test_http_admin_user_remove_auth_not_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------------
        #check admin user remove
        funcURL = "admin/user/remove/v1"
        inputData ={
            "token": user2R['token'],
            "u_id": user3R['auth_user_id']
        }
        adminUserRemove = requests.delete(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Only owners can remove members</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________ test_http_admin_user_remove_auth_only_owner __________________

    def test_http_admin_user_remove_auth_only_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        #check admin user remove
        funcURL = "admin/user/remove/v1"
        inputData ={
            "token": userR['token'],
            "u_id": userR['auth_user_id']
        }
        adminUserRemove = requests.delete(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Cannot remove last owner</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________ test_http_admin_userpermission_u_id_does_not_exist ______________

    def test_http_admin_userpermission_u_id_does_not_exist():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmai.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
        # ----------------------------
        #chec admin user permission
        funcURL = "admin/userpermission/change/v1"
        inputData ={
            "token": userR['token'],
            "u_id": 3,
            "permission_id": 1
        }
        adminUserPermission = requests.post(config.url + funcURL, json=inputData)
>       adminUserPermissionR = json.loads(adminUserPermission.text)

http_tests/admin_http_test.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>3 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________ test_http_admin_userpermission_permission_id_not_valid ____________

    def test_http_admin_userpermission_permission_id_not_valid():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmai.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        #check admin user permission
        funcURL = "admin/userpermission/change/v1"
        inputData ={
            "token": userR['token'],
            "u_id": user2R['auth_user_id'],
            "permission_id": 5
        }
        adminUserPermission = requests.post(config.url + funcURL, json=inputData)
>       adminUserPermissionR = json.loads(adminUserPermission.text)

http_tests/admin_http_test.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Invalid permission ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________ test_http_admin_userpermission_auth_not_owner _________________

    def test_http_admin_userpermission_auth_not_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------------
        #check admin user rpermssion
        funcURL = "admin/userpermission/change/v1"
        inputData ={
            "token": user2R['token'],
            "u_id": user3R['auth_user_id'],
            "permission_id": 1
    
        }
        adminUserRemove = requests.post(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Only owners can modify permissions</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________ test_http_auth_register_already_registered_email _______________

    def test_http_auth_register_already_registered_email():
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>test@hotmail.com already taken</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________ test_http_auth_register_invalid_email _____________________

    def test_http_auth_register_invalid_email():
        requests.delete(config.url + "clear/v1")
    
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email is invalid</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________ test_http_auth_register_short_first ______________________

    def test_http_auth_register_short_first():
        requests.delete(config.url + "clear/v1")
    
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password1",
            "name_first": "",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email is invalid</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_auth_register_short_last ______________________

    def test_http_auth_register_short_last():
        requests.delete(config.url + "clear/v1")
    
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email is invalid</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_auth_register_long_first ______________________

    def test_http_auth_register_long_first():
        requests.delete(config.url + "clear/v1")
    
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password1",
            "name_first": "nameFirst" * 15,
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email is invalid</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_auth_register_long_last _______________________

    def test_http_auth_register_long_last():
        requests.delete(config.url + "clear/v1")
    
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast" * 15,
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email is invalid</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_auth_login_invalid_email ______________________

    def test_http_auth_login_invalid_email():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/login/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password1",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       testOutput = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email or password is incorrect</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________ test_http_auth_login_unregistered_email ____________________

    def test_http_auth_login_unregistered_email():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/login/v2"
        inputData = {
            "email": "unregistered@hotmail.com",
            "password": "password1",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       testOutput = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email or password is incorrect</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________ test_http_auth_login_incorrect_password ____________________

    def test_http_auth_login_incorrect_password():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/login/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       testOutput = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email or password is incorrect</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_logout_invalid_token_key ______________________

    def test_http_logout_invalid_token_key():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/logout/v1"
        inputData = {"token": jwt.encode({"invalidKey": 6}, database.secretSauce, algorithm="HS256")}
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Not logged in bro</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________ test_http_logout_invalid_token_value _____________________

    def test_http_logout_invalid_token_value():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/logout/v1"
        inputData = {"token": jwt.encode({"sessionId": "notAnInt"}, database.secretSauce, algorithm="HS256")}
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Not logged in bro</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________ test_http_logout_invalid_token_type ______________________

    def test_http_logout_invalid_token_type():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/logout/v1"
        inputData = {"token": jwt.encode({"invalidKey": 9999}, database.secretSauce, algorithm="HS256")}
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Not logged in bro</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_logout_nonexistant_user _______________________

    def test_http_logout_nonexistant_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/logout/v1"
        inputData = {"token": jwt.encode({"sessionId": -99999}, database.secretSauce, algorithm="HS256")}
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:326: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Not logged in bro</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________ test_http_passwordreset_request_invalid_email _________________

    def test_http_passwordreset_request_invalid_email():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # Reset--------------------
        funcURL = "auth/passwordreset/request/v1"
        inputData = {
            "email": "invalidemail@hotmail.com",
        }
        rawResponseData  = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:371: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Couldn\'t find invalidemail@hotmail.com. Check your spelling and try again</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________ test_http_passwordreset_reset_invalid_code __________________

    def test_http_passwordreset_reset_invalid_code():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # Reset--------------------
        funcURL = "auth/passwordreset/reset/v1"
        inputData = {
            "reset_code": "invalidcode",
            "new_password": "newpassword",
        }
        rawResponseData  = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Invalid reset code: invalidcode</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________ test_http_passwordreset_reset_invalid_password ________________

    def test_http_passwordreset_reset_invalid_password():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # Reset--------------------
        funcURL = "auth/passwordreset/reset/v1"
        inputData = {
            "reset_code": "validcode",
            "new_password": "pass",
        }
        rawResponseData  = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Invalid reset code: validcode</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________ testjoin_invalid_channelID __________________________

    def testjoin_invalid_channelID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(channel.text)
    
        # Channel Join -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_id",
        }
        join = requests.post(config.url + funcURL, json=inputData)
>       joinR = json.loads(join.text)

http_tests/channel_http_test.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testjoin_invalid_tokenn ____________________________

    def testjoin_invalid_tokenn():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join -------
        funcURL = "channel/join/v2"
        temp = jwt.encode({"sessionId": 2000}, database.secretSauce, algorithm = "HS256")
        inputData = {
            "token": temp,
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
>       joinR = json.loads(join.text)

http_tests/channel_http_test.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testjoin_joined_already ____________________________

    def testjoin_joined_already():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(join.text)
    
        # Channel Join Error -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        join2 = requests.post(config.url + funcURL, json=inputData)
>       join2R = json.loads(join2.text)

http_tests/channel_http_test.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast0 is already a member of testchannel</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testjoin_private_channel ___________________________

    def testjoin_private_channel():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": False,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
>       joinR = json.loads(join.text)

http_tests/channel_http_test.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>You don\'t have permission to join this channel</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testjoin_already_joined ____________________________

    def testjoin_already_joined():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": False,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
>       joinR = json.loads(join.text)

http_tests/channel_http_test.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of testchannel</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________________ testjoin_valid_case ______________________________

    def testjoin_valid_case():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Register Third Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join (Second Person) -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(join.text)
    
        # Channel Join (Third Person) -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user3R["token"],
            "channel_id": channelR["channel_id"],
        }
        join2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(join2.text)
    
        # Channel Details
        funcURL = "channel/details/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
        }
        qData = urllib.parse.urlencode(inputData)
        channelDetails = requests.get(config.url + funcURL + "?" + qData)
        channelDetailsR = json.loads(channelDetails.text)
    
>       assert channelDetailsR["all_members"] == [
            {
                'u_id': userR["auth_user_id"],
                'email': 'test@hotmail.com',
                'name_first': 'nameFirst',
                'name_last': 'nameLast',
                'handle_str': 'namefirstnamelast',
                'profile_img_url': channelDetailsR["all_members"][0]["profile_img_url"],
            },
            {
                'u_id': user2R["auth_user_id"],
                'email': 'test2@hotmail.com',
                'name_first': 'nameFirst',
                'name_last': 'nameLast',
                'handle_str': 'namefirstnamelast0',
                'profile_img_url': channelDetailsR["all_members"][1]["profile_img_url"],
            },
            {
                'u_id': user3R["auth_user_id"],
                'email': 'test3@hotmail.com',
                'name_first': 'nameFirst',
                'name_last': 'nameLast',
                'handle_str': 'namefirstnamelast1',
                'profile_img_url': channelDetailsR["all_members"][2]["profile_img_url"],
            }
        ]
E       AssertionError: assert [{'email': 'test3@hotmail.com',\n  'handle_str': 'namefirstnamelast1',\n  'name_first': 'nameFirst',\n  'name_last': 'nameLast',\n  'profile_img_url': '',\n  'u_id': 73},\n {'email': 'test2@hotmail.com',\n  'handle_str': 'namefirstnamelast0',\n  'name_first': 'nameFirst',\n  'name_last': 'nameLast',\n  'profile_img_url': '',\n  'u_id': 72},\n {'email': 'test@hotmail.com',\n  'handle_str': 'namefirstnamelast',\n  'name_first': 'nameFirst',\n  'name_last': 'nameLast',\n  'profile_img_url': '',\n  'u_id': 71}] == [{'email': 'test@hotmail.com',\n  'handle_str': 'namefirstnamelast',\n  'name_first': 'nameFirst',\n  'name_last': 'nameLast',\n  'profile_img_url': '',\n  'u_id': 71},\n {'email': 'test2@hotmail.com',\n  'handle_str': 'namefirstnamelast0',\n  'name_first': 'nameFirst',\n  'name_last': 'nameLast',\n  'profile_img_url': '',\n  'u_id': 72},\n {'email': 'test3@hotmail.com',\n  'handle_str': 'namefirstnamelast1',\n  'name_first': 'nameFirst',\n  'name_last': 'nameLast',\n  'profile_img_url': '',\n  'u_id': 73}]
E         At index 0 diff: {'email': 'test3@hotmail.com', 'handle_str': 'namefirstnamelast1', 'name_first': 'nameFirst', 'name_last': 'nameLast', 'profile_img_url': '', 'u_id': 73} != {'u_id': 71, 'email': 'test@hotmail.com', 'name_first': 'nameFirst', 'name_last': 'nameLast', 'handle_str': 'namefirstnamelast', 'profile_img_url': ''}
E         Full diff:
E           [
E         +  {'email': 'test3@hotmail.com',
E         +   'handle_str': 'namefirstnamelast1',
E         +   'name_first': 'nameFirst',
E         +   'name_last': 'nameLast',
E         +   'profile_img_url': '',
E         +   'u_id': 73},
E         +  {'email': 'test2@hotmail.com',
E         +   'handle_str': 'namefirstnamelast0',
E         +   'name_first': 'nameFirst',
E         +   'name_last': 'nameLast',
E         +   'profile_img_url': '',
E         +   'u_id': 72},
E            {'email': 'test@hotmail.com',
E             'handle_str': 'namefirstnamelast',
E             'name_first': 'nameFirst',
E             'name_last': 'nameLast',
E             'profile_img_url': '',
E             'u_id': 71},
E         -  {'email': 'test2@hotmail.com',
E         -   'handle_str': 'namefirstnamelast0',
E         -   'name_first': 'nameFirst',
E         -   'name_last': 'nameLast',
E         -   'profile_img_url': '',
E         -   'u_id': 72},
E         -  {'email': 'test3@hotmail.com',
E         -   'handle_str': 'namefirstnamelast1',
E         -   'name_first': 'nameFirst',
E         -   'name_last': 'nameLast',
E         -   'profile_img_url': '',
E         -   'u_id': 73},
E           ]

http_tests/channel_http_test.py:320: AssertionError
_________________________ testaddowner_invalid_tokenn __________________________

    def testaddowner_invalid_tokenn():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Add Owner ------
        funcURL = "channel/addowner/v1"
        temp = jwt.encode({"sessionId": 243343}, database.secretSauce, algorithm = "HS256")
        inputData = {
            "token": temp,
            "channel_id": channelR["channel_id"],
            "u_id": user2R["token"],
        }
        addOwner = requests.post(config.url + funcURL, json=inputData)
>       addOwnerR = json.loads(addOwner.text)

http_tests/channel_http_test.py:395: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testaddowner_invalid_uID ___________________________

    def testaddowner_invalid_uID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Add Owner ------
        funcURL = "channel/addowner/v1"
        temp = jwt.encode({"sessionId": 243343}, database.secretSauce, algorithm = "HS256")
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "u_id": temp,
        }
        addOwner = requests.post(config.url + funcURL, json=inputData)
>       addOwnerR = json.loads(addOwner.text)

http_tests/channel_http_test.py:444: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ testaddowner_invalid_channelID ________________________

    def testaddowner_invalid_channelID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(channel.text)
    
        # Add Owner ------
        funcURL = "channel/addowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_channel",
            "u_id": user2R["auth_user_id"],
        }
        addOwner = requests.post(config.url + funcURL, json=inputData)
>       addOwnerR = json.loads(addOwner.text)

http_tests/channel_http_test.py:492: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________ testaddowner_already_owner __________________________

    def testaddowner_already_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(channel.text)
    
        # Add Owner ------
        funcURL = "channel/addowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_channel",
            "u_id": userR["auth_user_id"],
        }
        addOwner = requests.post(config.url + funcURL, json=inputData)
>       addOwnerR = json.loads(addOwner.text)

http_tests/channel_http_test.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ testaddowner_unauthorised_token ________________________

    def testaddowner_unauthorised_token():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Register Third Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join Person 2 -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(join.text)
    
        # Channel Join Person 3 -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user3R["token"],
            "channel_id": channelR["channel_id"],
        }
        join2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(join2.text)
    
        # Add Owner ------
        funcURL = "channel/addowner/v1"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
            "u_id": user3R["auth_user_id"],
        }
        addOwner = requests.post(config.url + funcURL, json=inputData)
>       addOwnerR = json.loads(addOwner.text)

http_tests/channel_http_test.py:617: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>You don\'t have permission to add an owner</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ testaddowner_not_in_channel __________________________

    def testaddowner_not_in_channel():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Register Third Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join Person 2 -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(join.text)
    
        # Add Owner ------
        funcURL = "channel/addowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "u_id": user3R["auth_user_id"],
        }
        addOwner = requests.post(config.url + funcURL, json=inputData)
        addOwnerR = json.loads(addOwner.text)
>       assert addOwnerR["code"] == 403
E       KeyError: 'code'

http_tests/channel_http_test.py:686: KeyError
__________________ test_http_channel_removeowner_invalid_user __________________

    def test_http_channel_removeowner_invalid_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Adding Owner--------------------
        funcURL = "channel/addowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "u_id": user2R["auth_user_id"],
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Removing Owner--------------------
        funcURL = "channel/removeowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "u_id": "invalid_user",
        }
        removeOwner = requests.post(config.url + funcURL, json=inputData)
>       removeOwnerR = json.loads(removeOwner.text)

http_tests/channel_http_test.py:888: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________ test_http_channel_removeowner_invalid_channel _________________

    def test_http_channel_removeowner_invalid_channel():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Adding Owner--------------------
        funcURL = "channel/addowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "u_id": user2R["auth_user_id"],
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Removing Owner--------------------
        funcURL = "channel/removeowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_channel",
            "u_id": user2R["auth_user_id"],
        }
        removeOwner = requests.post(config.url + funcURL, json=inputData)
>       removeOwnerR = json.loads(removeOwner.text)

http_tests/channel_http_test.py:943: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________ test_http_channel_removeowner_only_owner ___________________

    def test_http_channel_removeowner_only_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Removing Owner--------------------
        funcURL = "channel/removeowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_channel",
            "u_id": userR["auth_user_id"],
        }
        removeOwner = requests.post(config.url + funcURL, json=inputData)
>       removeOwnerR = json.loads(removeOwner.text)

http_tests/channel_http_test.py:977: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________ test_http_channel_removeowner_not_owner ____________________

    def test_http_channel_removeowner_not_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Removing Owner--------------------
        funcURL = "channel/removeowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_channel",
            "u_id": user2R["auth_user_id"],
        }
        removeOwner = requests.post(config.url + funcURL, json=inputData)
>       removeOwnerR = json.loads(removeOwner.text)

http_tests/channel_http_test.py:1022: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________ test_http_channel_removeowner_invalid_token __________________

    def test_http_channel_removeowner_invalid_token():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Removing Owner--------------------
        funcURL = "channel/removeowner/v1"
        inputData = {
            "token": user2R["token"],
            "channel_id": "invalid_channel",
            "u_id": userR["auth_user_id"],
        }
        removeOwner = requests.post(config.url + funcURL, json=inputData)
>       removeOwnerR = json.loads(removeOwner.text)

http_tests/channel_http_test.py:1067: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________ test_http_channel_leave_channel_valid _____________________

    def test_http_channel_leave_channel_valid():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Leaving Channel--------------
        funcURL = "channel/leave/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_channel_id"
        }
        channelLeave = requests.post(config.url + funcURL, json=inputData)
>       channelLeaveR = json.loads(channelLeave.text)

http_tests/channel_http_test.py:1152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_channel_leave_user_valid ______________________

    def test_http_channel_leave_user_valid():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
        # Leaving Channel--------------
        funcURL = "channel/leave/v1"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"]
        }
        channelLeave = requests.post(config.url + funcURL, json=inputData)
>       channelLeaveR = json.loads(channelLeave.text)

http_tests/channel_http_test.py:1198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Not a member of testChannel</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_channel_messages_working ______________________

    def test_http_channel_messages_working():
    
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
    
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Hello World",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Channel Message Info -------
        funcURL = "channel/messages/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        channelMessages = requests.get(config.url + funcURL + "?" + qData)
        channelMessagesR = json.loads(channelMessages.text)
    
        for msg in channelMessagesR["messages"]:
>           assert msg["message_id"] == 1
E           assert 125 == 1
E             +125
E             -1

http_tests/channel_http_test.py:1252: AssertionError
__________________ test_http_channel_messages_invalid_channel __________________

    def test_http_channel_messages_invalid_channel():
    
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Message Info -------
        funcURL = "channel/messages/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": 50,
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        channelMessages = requests.get(config.url + funcURL + "?" + qData)
>       channelMessagesR = json.loads(channelMessages.text)

http_tests/channel_http_test.py:1280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>50 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________ test_http_channel_messages_startgreater ____________________

    def test_http_channel_messages_startgreater():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
        # Checking Messages-----------------
        funcURL = "channel/messages/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "start": 1,
        }
        qData = urllib.parse.urlencode(inputData)
        dmMessages = requests.get(config.url + funcURL + "?" + qData)
>       dmMessagesR = json.loads(dmMessages.text)

http_tests/channel_http_test.py:1318: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Incorrect pagination start (1 &gt; 0)</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________ test_http_channel_messages_not_authorised ___________________

    def test_http_channel_messages_not_authorised():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
    
        # Checking Messages-----------------
        funcURL = "channel/messages/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        dmMessages = requests.get(config.url + funcURL + "?" + qData)
>       dmMessagesR = json.loads(dmMessages.text)

http_tests/channel_http_test.py:1368: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Only members can view messages</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_channels_create_working _______________________

    def test_http_channels_create_working():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
    
>       assert channelR["channel_id"] == 0
E       assert 135 == 0
E         +135
E         -0

http_tests/channels_http_test.py:39: AssertionError
______________________ test_http_channels_create_multiple ______________________

    def test_http_channels_create_multiple():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "Channel2",
            "is_public": True,
        }
        channel2 = requests.post(config.url + funcURL, json=inputData)
        channel2R = json.loads(channel2.text)
        # ----------------------------
    
>       assert channelR["channel_id"] == 0
E       assert 137 == 0
E         +137
E         -0

http_tests/channels_http_test.py:79: AssertionError
___________________ test_http_channels_create_invalid_token ____________________

    def test_http_channels_create_invalid_token():
    
        requests.delete(config.url + "clear/v1")
        temp = jwt.encode({"sessionId": 7}, database.secretSauce, algorithm = "HS256")
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": temp,
            "name": "TestChannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
>       channelR = json.loads(channel.text)

http_tests/channels_http_test.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________ test_http_channels_create_longer_than_twenty_char _______________

    def test_http_channels_create_longer_than_twenty_char():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "a" * 21,
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
>       channelR = json.loads(channel.text)

http_tests/channels_http_test.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Channel name too long</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ test_http_channels_list_working ________________________

    def test_http_channels_list_working():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": user2R["token"],
            "name": "testChannel2",
            "is_public": True,
        }
        channel2 = requests.post(config.url + funcURL, json=inputData)
        channel2R = json.loads(channel2.text)
        # ----------------------------
    
        # Channel Join -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        # Listing Channel--------------
        funcURL = "channels/list/v2"
        inputData = {
            "token": user2R["token"],
        }
        qData = urllib.parse.urlencode(inputData)
        channelList = requests.get(config.url + funcURL + "?" + qData)
        channelListR = json.loads(channelList.text)
    
>       assert channelListR == {'channels': [{'channel_id': channelR["channel_id"], 'name': 'testChannel'}, {'channel_id': channel2R["channel_id"], 'name': 'testChannel2'}]}
E       AssertionError: assert {'channels': [{'channel_id': 144, 'name': 'testChannel2'},\n              {'channel_id': 143, 'name': 'testChannel'}]} == {'channels': [{'channel_id': 143, 'name': 'testChannel'},\n              {'channel_id': 144, 'name': 'testChannel2'}]}
E         Differing items:
E         {'channels': [{'channel_id': 144, 'name': 'testChannel2'}, {'channel_id': 143, 'name': 'testChannel'}]} != {'channels': [{'channel_id': 143, 'name': 'testChannel'}, {'channel_id': 144, 'name': 'testChannel2'}]}
E         Full diff:
E           {
E         -  'channels': [{'channel_id': 143, 'name': 'testChannel'},
E         ?                                ^
E         +  'channels': [{'channel_id': 144, 'name': 'testChannel2'},
E         ?                                ^                      +
E         -               {'channel_id': 144, 'name': 'testChannel2'}],
E         ?                                ^                      -
E         +               {'channel_id': 143, 'name': 'testChannel'}],
E         ?                                ^
E           }

http_tests/channels_http_test.py:197: AssertionError
_____________________ test_http_channels_list_invalid_user _____________________

    def test_http_channels_list_invalid_user():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        invalid_token = jwt.encode({"sessionId": 999}, database.secretSauce, algorithm = "HS256")
        # Listing Channel--------------
        funcURL = "channels/list/v2"
        inputData = {
            "token": invalid_token,
        }
        qData = urllib.parse.urlencode(inputData)
        channelList = requests.get(config.url + funcURL + "?" + qData)
>       channelListR = json.loads(channelList.text)

http_tests/channels_http_test.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________ test_http_channels_listall_invalid_user ____________________

    def test_http_channels_listall_invalid_user():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        invalid_token = jwt.encode({"sessionId": 999}, database.secretSauce, algorithm = "HS256")
        # Listing Channel--------------
        funcURL = "channels/listall/v2"
        inputData = {
            "token": invalid_token,
        }
        qData = urllib.parse.urlencode(inputData)
        channelList = requests.get(config.url + funcURL + "?" + qData)
>       channelListR = json.loads(channelList.text)

http_tests/channels_http_test.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ test_http_dm_create_working __________________________

    def test_http_dm_create_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
>       assert dmR == {
            'dm_id': 0,
            'dm_name': "namefirstnamelast, namefirstnamelast0"
        }
E       AssertionError: assert {'dm_id': 152, 'dm_name': 'namefirstnamelast, namefirstnamelast0'} == {'dm_id': 0, 'dm_name': 'namefirstnamelast, namefirstnamelast0'}
E         Common items:
E         {'dm_name': 'namefirstnamelast, namefirstnamelast0'}
E         Differing items:
E         {'dm_id': 152} != {'dm_id': 0}
E         Full diff:
E         - {'dm_id': 0, 'dm_name': 'namefirstnamelast, namefirstnamelast0'}
E         ?           ^
E         + {'dm_id': 152, 'dm_name': 'namefirstnamelast, namefirstnamelast0'}
E         ?           ^^^

http_tests/dm_http_test.py:46: AssertionError
_______________________ test_http_dm_create_invalid_user _______________________

    def test_http_dm_create_invalid_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        userList.append(7)
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>7 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_dm_create_invalid_token _______________________

    def test_http_dm_create_invalid_token():
        requests.delete(config.url + "clear/v1")
        temp = jwt.encode({"sessionId": 7}, database.secretSauce, algorithm = "HS256")
    
        funcURL = "dm/create/v1"
        inputData = {
            "token": temp,
            "u_ids": [],
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ test_http_dm_invite_working __________________________

    def test_http_dm_invite_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Inviting User 3 to DM-----------------
        funcURL = "dm/invite/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": 0,
            "u_id": 2
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # List the DMS that user 3 is in
        funcURL = "dm/list/v1"
        inputData = {
                "token": user3R["token"],
        }
        qData = urllib.parse.urlencode(inputData)
        dmList = requests.get(config.url + funcURL + "?" + qData)
        dmListR = json.loads(dmList.text)
    
>       assert dmListR == {"dms": [{"dm_id": 0, "name": "namefirstnamelast, namefirstnamelast0"}]}
E       AssertionError: assert {'dms': []} == {'dms': [{'dm_id': 0, 'name': 'namefirstnamelast, namefirstnamelast0'}]}
E         Differing items:
E         {'dms': []} != {'dms': [{'dm_id': 0, 'name': 'namefirstnamelast, namefirstnamelast0'}]}
E         Full diff:
E         - {'dms': [{'dm_id': 0, 'name': 'namefirstnamelast, namefirstnamelast0'}]}
E         + {'dms': []}

http_tests/dm_http_test.py:171: AssertionError
_______________________ test_http_dm_invite_invalid_dmid _______________________

    def test_http_dm_invite_invalid_dmid():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # ----------------------------
    
        # Invite-----------------
        funcURL = "dm/invite/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": 0,
            "u_id": 1
        }
        dmInv = requests.post(config.url + funcURL, json=inputData)
>       dmInvR = json.loads(dmInv.text)

http_tests/dm_http_test.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>0 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ test_http_dm_invite_invalid_uid ________________________

    def test_http_dm_invite_invalid_uid():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Invite-----------------
        funcURL = "dm/invite/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": 0,
            "u_id": 8
        }
        dmInv = requests.post(config.url + funcURL, json=inputData)
>       dmInvR = json.loads(dmInv.text)

http_tests/dm_http_test.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>0 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ test_http_dm_inviter_not_in_dm ________________________

    def test_http_dm_inviter_not_in_dm():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------
    
         # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test4@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        user4R = json.loads(user3.text)
        # ----------------------------
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Invite-----------------
        funcURL = "dm/invite/v1"
        inputData = {
            "token": user3R["token"],
            "dm_id": 0,
            "u_id": user4R["auth_user_id"]
        }
        dmInv = requests.post(config.url + funcURL, json=inputData)
>       dmInvR = json.loads(dmInv.text)

http_tests/dm_http_test.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>0 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________ test_http_dm_list_working ___________________________

    def test_http_dm_list_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user3R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Creating DM LIST---------------
        funcURL = "dm/list/v1"
        inputData = {
                "token": userR["token"],
        }
        qData = urllib.parse.urlencode(inputData)
        dmList = requests.get(config.url + funcURL + "?" + qData)
        dmListR = json.loads(dmList.text)
>       assert dmListR == {"dms": [{"dm_id": 0, "name": "namefirstnamelast, namefirstnamelast0"},
         {"dm_id": 1, "name": "namefirstnamelast, namefirstnamelast1"}]}
E       AssertionError: assert {'dms': [{'dm_id': 173, 'name': 'namefirstnamelast, namefirstnamelast1'},\n         {'dm_id': 172, 'name': 'namefirstnamelast, namefirstnamelast0'}]} == {'dms': [{'dm_id': 0, 'name': 'namefirstnamelast, namefirstnamelast0'},\n         {'dm_id': 1, 'name': 'namefirstnamelast, namefirstnamelast1'}]}
E         Differing items:
E         {'dms': [{'dm_id': 173, 'name': 'namefirstnamelast, namefirstnamelast1'}, {'dm_id': 172, 'name': 'namefirstnamelast, namefirstnamelast0'}]} != {'dms': [{'dm_id': 0, 'name': 'namefirstnamelast, namefirstnamelast0'}, {'dm_id': 1, 'name': 'namefirstnamelast, namefirstnamelast1'}]}
E         Full diff:
E           {
E         -  'dms': [{'dm_id': 0, 'name': 'namefirstnamelast, namefirstnamelast0'},
E         ?                    ^                                               ^
E         +  'dms': [{'dm_id': 173, 'name': 'namefirstnamelast, namefirstnamelast1'},
E         ?                    ^^^                                               ^
E         -          {'dm_id': 1, 'name': 'namefirstnamelast, namefirstnamelast1'}],
E         ?                                                                    ^
E         +          {'dm_id': 172, 'name': 'namefirstnamelast, namefirstnamelast0'}],
E         ?                     ++                                               ^
E           }

http_tests/dm_http_test.py:397: AssertionError
_______________________ test_http_dm_list_invalid_token ________________________

    def test_http_dm_list_invalid_token():
        requests.delete(config.url + "clear/v1")
        temp = jwt.encode({"sessionId": 7}, database.secretSauce, algorithm = "HS256")
    
        funcURL = "dm/list/v1"
        inputData = {
                "token": temp,
        }
        qData = urllib.parse.urlencode(inputData)
        dmList = requests.get(config.url + funcURL + "?" + qData)
>       dmListR = json.loads(dmList.text)

http_tests/dm_http_test.py:410: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ test_http_dm_leave_invalid_dm _________________________

    def test_http_dm_leave_invalid_dm():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Leaving DM-----------------
        funcURL = "dm/leave/v1"
        inputData = {
            "token": user2R["token"],
            "dm_id": "invalid_dm_id",
        }
        dmLeft = requests.post(config.url + funcURL, json=inputData)
>       dmLeftR = json.loads(dmLeft.text)

http_tests/dm_http_test.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________ test_http_dm_leave_unauthorized_user _____________________

    def test_http_dm_leave_unauthorized_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
         # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
        # ----------------------------
        # Leaving DM-----------------
        funcURL = "dm/leave/v1"
        inputData = {
            "token": user3R["token"],
            "dm_id": dmR["dm_id"],
        }
        dmLeft = requests.post(config.url + funcURL, json=inputData)
>       dmLeftR = json.loads(dmLeft.text)

http_tests/dm_http_test.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Not a member of namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ test_http_dm_leave_invalid_token _______________________

    def test_http_dm_leave_invalid_token():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
        # ----------------------------
        temp = jwt.encode({"sessionId": 7}, database.secretSauce, algorithm = "HS256")
        # Leaving DM-----------------
        funcURL = "dm/leave/v1"
        inputData = {
            "token": temp,
            "dm_id": dmR["dm_id"],
        }
        dmLeft = requests.post(config.url + funcURL, json=inputData)
>       dmLeftR = json.loads(dmLeft.text)

http_tests/dm_http_test.py:621: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ test_http_dm_remove_invalid_id ________________________

    def test_http_dm_remove_invalid_id():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Removing DM-----------------
        funcURL = "dm/remove/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": "invalid_dm_id",
        }
        dmRemoved = requests.delete(config.url + funcURL, json=inputData)
>       dmRemovedR = json.loads(dmRemoved.text)

http_tests/dm_http_test.py:733: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ test_http_dm_remove_not_owner _________________________

    def test_http_dm_remove_not_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
        # ----------------------------
        # Removing DM-----------------
        funcURL = "dm/remove/v1"
        inputData = {
            "token": user2R["token"],
            "dm_id": dmR["dm_id"],
        }
        dmRemoved = requests.delete(config.url + funcURL, json=inputData)
>       dmRemovedR = json.loads(dmRemoved.text)

http_tests/dm_http_test.py:781: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>You don\'t have permission to remove this DM</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_dm_remove_invalid_token _______________________

    def test_http_dm_remove_invalid_token():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
        # ----------------------------
        temp = jwt.encode({"sessionId": 2}, database.secretSauce, algorithm = "HS256")
        # Removing DM-----------------
        funcURL = "dm/remove/v1"
        inputData = {
            "token": temp,
            "dm_id": dmR["dm_id"],
        }
        dmRemoved = requests.delete(config.url + funcURL, json=inputData)
>       dmRemovedR = json.loads(dmRemoved.text)

http_tests/dm_http_test.py:830: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_dm_message_invalid_user _______________________

    def test_http_dm_message_invalid_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
        # ----------------------------
        temp = jwt.encode({"sessionId": 7}, database.secretSauce, algorithm = "HS256")
        # Checking Messages-----------------
        funcURL = "dm/messages/v1"
        inputData = {
            "token": temp,
            "dm_id": dmR["dm_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        dmMessages = requests.get(config.url + funcURL + "?" + qData)
>       dmMessagesR = json.loads(dmMessages.text)

http_tests/dm_http_test.py:931: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ test_http_dm_message_invalid_dm ________________________

    def test_http_dm_message_invalid_dm():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Checking Messages-----------------
        funcURL = "dm/messages/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": 999,
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        dmMessages = requests.get(config.url + funcURL + "?" + qData)
>       dmMessagesR = json.loads(dmMessages.text)

http_tests/dm_http_test.py:979: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>999 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________ test_http_dm_message_unauthorised_user ____________________

    def test_http_dm_message_unauthorised_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
        # ----------------------------
        # Checking Messages-----------------
        funcURL = "dm/messages/v1"
        inputData = {
            "token": user3R["token"],
            "dm_id": dmR["dm_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        dmMessages = requests.get(config.url + funcURL + "?" + qData)
>       dmMessagesR = json.loads(dmMessages.text)

http_tests/dm_http_test.py:1040: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Only members can view messages</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_dm_message_startgreater _______________________

    def test_http_dm_message_startgreater():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
        # ----------------------------
        # Checking Messages-----------------
        funcURL = "dm/messages/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": dmR["dm_id"],
            "start": 1,
        }
        qData = urllib.parse.urlencode(inputData)
        dmMessages = requests.get(config.url + funcURL + "?" + qData)
>       dmMessagesR = json.loads(dmMessages.text)

http_tests/dm_http_test.py:1090: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Incorrect pagination start (1 &gt; 0)</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________ test_http_dm_details_dm_does_not_exist ____________________

    def test_http_dm_details_dm_does_not_exist():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(dm.text)
        # ----------------------------
        # checking details -----------
        funcURL = "dm/details/v1"
        inputData = {
            "token": userR['token'],
            "dm_id": 1242134
        }
        qData = urllib.parse.urlencode(inputData)
        dmDetails = requests.get(config.url + funcURL + "?" + qData)
>       dmDetailsR = json.loads(dmDetails.text)

http_tests/dm_http_test.py:1191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>1242134 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________ test_http_dm_details_user_not_member_of_dm __________________

    def test_http_dm_details_user_not_member_of_dm():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        inputData = {
            "token": userR["token"],
            "u_ids": [user2R["auth_user_id"]],
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
        # ---------------------------
        # checking details -----------
        funcURL = "dm/details/v1"
        inputData = {
            "token": user3R['token'],
            "dm_id": dmR["dm_id"]
        }
        qData = urllib.parse.urlencode(inputData)
        dmDetails = requests.get(config.url + funcURL + "?" + qData)
>       dmDetailsR = json.loads(dmDetails.text)

http_tests/dm_http_test.py:1249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Only members can view details about this channel</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________________ test_echo ___________________________________

    def test_echo():
        '''
        A simple test to check echo
        '''
        resp = requests.get(config.url + 'echo', params={'data': 'hello'})
>       assert json.loads(resp.text) == {'data': 'hello'}

http_tests/echo_http_test.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________________ testsend_empty_message ____________________________

    def testsend_empty_message():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message send
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": '',
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
>       assert messageSendR["code"] == 400
E       KeyError: 'code'

http_tests/message_http_test.py:54: KeyError
__________________________ testsend_invalid_long_msg ___________________________

    def testsend_invalid_long_msg():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message send
        funcURL = "message/send/v2"
        temp = 'x' * 2000
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": temp,
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
>       messageSendR = json.loads(messageSend.text)

http_tests/message_http_test.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Messages should be between 0 and 1000 characters long</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________________ testsend_invalid_token ____________________________

    def testsend_invalid_token():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message send
        funcURL = "message/send/v2"
        invalid_token = jwt.encode({"sessionId": 2954}, database.secretSauce, algorithm = "HS256")
    
        inputData = {
            "token": invalid_token,
            "channel_id": channelR["channel_id"],
            "message": "This is a message from Thomas Chen",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
>       messageSendR = json.loads(messageSend.text)

http_tests/message_http_test.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testsend_invalid_channel ___________________________

    def testsend_invalid_channel():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Message send
        funcURL = "message/send/v2"
    
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_id",
            "message": "This is a message from Thomas Chen",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
>       messageSendR = json.loads(messageSend.text)

http_tests/message_http_test.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ testsend_sent_not_in_channel _________________________

    def testsend_sent_not_in_channel():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message send
        funcURL = "message/send/v2"
    
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
            "message": "This is a message from Thomas Chen",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
>       messageSendR = json.loads(messageSend.text)

http_tests/message_http_test.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>namefirstnamelast0 not a member of testchannel</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________________ testsend_valid_case ______________________________

    def testsend_valid_case():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
    
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "lol",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Channel Message Info -------
        funcURL = "channel/messages/v2"
    
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        channelMessages = requests.get(config.url + funcURL + "?" + qData)
        channelMessagesR = json.loads(channelMessages.text)
    
        for msg in channelMessagesR["messages"]:
>           assert msg["message_id"] == 1
E           assert 242 == 1
E             +242
E             -1

http_tests/message_http_test.py:266: AssertionError
__________________________ testedit_invalid_long_msg ___________________________

    def testedit_invalid_long_msg():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas Chen and Jonathan Qiu",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Edit
        funcURL = "message/edit/v2"
        temp = 'x' * 9999
    
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
            "message": temp,
        }
        messageEdit = requests.put(config.url + funcURL, json=inputData)
>       messageEditR = json.loads(messageEdit.text)

http_tests/message_http_test.py:318: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Messages should be between 0 and 1000 characters long</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________________ testedit_invalid_token ____________________________

    def testedit_invalid_token():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas Chen and Jonathan Qiu",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Edit
        funcURL = "message/edit/v2"
        invalid_token = jwt.encode({"sessionId": 2}, database.secretSauce, algorithm = "HS256")
    
        inputData = {
            "token": invalid_token,
            "message_id": messageSendR["message_id"],
            "message": "Change this to Jonathan Qiu",
        }
        messageEdit = requests.put(config.url + funcURL, json=inputData)
>       messageEditR = json.loads(messageEdit.text)

http_tests/message_http_test.py:367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________________ testedit_invalid_mID _____________________________

    def testedit_invalid_mID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send --------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas Chen and Jonathan Qiu",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Message Edit ---------
        funcURL = "message/edit/v2"
    
        inputData = {
            "token": userR["token"],
            "message_id": "invalid_mID",
            "message": "Change this to Jonathan Qiu",
        }
        messageEdit = requests.put(config.url + funcURL, json=inputData)
>       messageEditR = json.loads(messageEdit.text)

http_tests/message_http_test.py:414: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testedit_not_authorised ____________________________

    def testedit_not_authorised():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas Chen and Jonathan Qiu",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Edit
        funcURL = "message/edit/v2"
    
        inputData = {
            "token": user2R["token"],
            "message_id": messageSendR["message_id"],
            "message": "Change this to Jonathan Qiu",
        }
    
        messageEdit = requests.put(config.url + funcURL, json=inputData)
>       messageEditR = json.loads(messageEdit.text)

http_tests/message_http_test.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>namefirstnamelast0 cannot edit this message</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________________ testedit_valid_case ______________________________

    def testedit_valid_case():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Edit ----------
        funcURL = "message/edit/v2"
    
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
            "message": "Jonathan",
        }
        messageEdit = requests.put(config.url + funcURL, json=inputData)
        _ = json.loads(messageEdit.text)
    
        # Channel Message Info -------
        funcURL = "channel/messages/v2"
    
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        channelMessages = requests.get(config.url + funcURL + "?" + qData)
        channelMessagesR = json.loads(channelMessages.text)
    
        for msg in channelMessagesR["messages"]:
>           assert msg["message_id"] == 1
E           assert 258 == 1
E             +258
E             -1

http_tests/message_http_test.py:535: AssertionError
_________________________ testedit_comprehensive_valid _________________________

    def testedit_comprehensive_valid():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join -----
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Edit ----------
        funcURL = "message/edit/v2"
    
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
            "message": "Jonathan",
        }
        messageEdit = requests.put(config.url + funcURL, json=inputData)
        _ = json.loads(messageEdit.text)
    
        # Channel Message Info -------
        funcURL = "channel/messages/v2"
    
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        channelMessages = requests.get(config.url + funcURL + "?" + qData)
        channelMessagesR = json.loads(channelMessages.text)
    
        for msg in channelMessagesR["messages"]:
>           assert msg["message_id"] == 1
E           assert 262 == 1
E             +262
E             -1

http_tests/message_http_test.py:618: AssertionError
_________________________ testremove_invalid_token_id __________________________

    def testremove_invalid_token_id():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send ------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas Chen and Jonathan Qiu",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Remove ----
        funcURL = "message/remove/v1"
        invalid_token = jwt.encode({"sessionId": 2}, database.secretSauce, algorithm = "HS256")
    
        inputData = {
            "token": invalid_token,
            "message_id": messageSendR["message_id"],
        }
        messageRemove = requests.delete(config.url + funcURL, json=inputData)
>       messageRemoveR = json.loads(messageRemove.text)

http_tests/message_http_test.py:669: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________________ testremove_invalid_mID ____________________________

    def testremove_invalid_mID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send ------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas Chen and Jonathan Qiu",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Message Remove ----
        funcURL = "message/remove/v1"
    
        inputData = {
            "token": userR["token"],
            "message_id": "invalid_id",
        }
        messageRemove = requests.delete(config.url + funcURL, json=inputData)
>       messageRemoveR = json.loads(messageRemove.text)

http_tests/message_http_test.py:716: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________________ testremove_empty _______________________________

    def testremove_empty():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Message Remove ----
        funcURL = "message/remove/v1"
    
        inputData = {
            "token": userR["token"],
            "message_id": "m_id",
        }
        messageRemove = requests.delete(config.url + funcURL, json=inputData)
>       messageRemoveR = json.loads(messageRemove.text)

http_tests/message_http_test.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testremove_unauthorised ____________________________

    def testremove_unauthorised():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join -----
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Remove ----
        funcURL = "message/remove/v1"
    
        inputData = {
            "token": user2R["token"],
            "message_id": messageSendR["message_id"],
        }
        messageRemove = requests.delete(config.url + funcURL, json=inputData)
>       messageRemoveR = json.loads(messageRemove.text)

http_tests/message_http_test.py:807: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>You do not have permission to remove messages</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ testsenddm_invalid_empty_message _______________________

    def testsenddm_invalid_empty_message():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Message Send DM -------
        funcURL = "message/senddm/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": dmR["dm_id"],
            "message": "",
        }
        messageSendDM = requests.post(config.url + funcURL, json=inputData)
        messageSendDMR = json.loads(messageSendDM.text)
>       assert messageSendDMR["code"] == 400
E       KeyError: 'code'

http_tests/message_http_test.py:1002: KeyError
_________________________ testsenddm_invalid_long_msg __________________________

    def testsenddm_invalid_long_msg():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Message Send DM -------
        funcURL = "message/senddm/v1"
        temp = 'x' * 2000
        inputData = {
            "token": userR["token"],
            "dm_id": dmR["dm_id"],
            "message": temp,
        }
        messageSendDM = requests.post(config.url + funcURL, json=inputData)
>       messageSendDMR = json.loads(messageSendDM.text)

http_tests/message_http_test.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Messages should be between 0 and 1000 characters long</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ testsenddm_invalid_token_ID __________________________

    def testsenddm_invalid_token_ID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Message Send DM -------
        funcURL = "message/senddm/v1"
        invalid_token = jwt.encode({"sessionId": "notInt"}, database.secretSauce, algorithm = "HS256")
        inputData = {
            "token": invalid_token,
            "dm_id": dmR["dm_id"],
            "message": "Jonathan Qiu is such a nice guy",
        }
        messageSendDM = requests.post(config.url + funcURL, json=inputData)
>       messageSendDMR = json.loads(messageSendDM.text)

http_tests/message_http_test.py:1100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testsenddm_invalid_dmID ____________________________

    def testsenddm_invalid_dmID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(dm.text)
    
        # Message Send DM -------
        funcURL = "message/senddm/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": "invalid_dmID",
            "message": "Jonathan Qiu is such a nice guy",
        }
        messageSendDM = requests.post(config.url + funcURL, json=inputData)
>       messageSendDMR = json.loads(messageSendDM.text)

http_tests/message_http_test.py:1148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ testsenddm_unauthorised_user _________________________

    def testsenddm_unauthorised_user():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Register Third Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
    
        # Message Send DM -------
        funcURL = "message/senddm/v1"
        inputData = {
            "token": user3R["token"],
            "dm_id": dmR["dm_id"],
            "message": "Jonathan Qiu is such a nice guy",
        }
        messageSendDM = requests.post(config.url + funcURL, json=inputData)
>       messageSendDMR = json.loads(messageSendDM.text)

http_tests/message_http_test.py:1208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>namefirstnamelast1 not a member of namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________________ testsenddm_valid_case _____________________________

    def testsenddm_valid_case():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Message Send DM -------
        funcURL = "message/senddm/v1"
        inputData = {
            "token": user2R["token"],
            "dm_id": dmR["dm_id"],
            "message": "Jonathan Qiu is such a nice guy",
        }
        messageSendDM = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSendDM.text)
    
        # DM Message Info -------
        funcURL = "dm/messages/v1"
    
        inputData = {
            "token": user2R["token"],
            "dm_id": dmR["dm_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        dmMessages = requests.get(config.url + funcURL + "?" + qData)
        dmMessagesR = json.loads(dmMessages.text)
    
        for msg in dmMessagesR["messages"]:
>           assert msg["message_id"] == 1
E           assert 301 == 1
E             +301
E             -1

http_tests/message_http_test.py:1271: AssertionError
___________ test_http_message_share_not_member_of_channel_sharing_to ___________

    def test_http_message_share_not_member_of_channel_sharing_to():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
    
        #checking message_share
        funcURL = "message/share/v1"
        invalidToken = jwt.encode({"sessionId": 8}, database.secretSauce, algorithm="HS256")
        inputData ={
            'token': invalidToken,
            'og_message_id': messageSendR["message_id"],
            'message': "",
            'channel_id': channelR['channel_id'],
            'dm_id': -1,
        }
        messageShare = requests.post(config.url + funcURL, json=inputData)
>       messageShareR = json.loads(messageShare.text)

http_tests/message_http_test.py:1363: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________ test_http_message_share_not_member_of_dm_sharing_to ______________

    def test_http_message_share_not_member_of_dm_sharing_to():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmai.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
         # Creating DM-----------------
        funcURL = "dm/create/v1"
        inputData = {
            "token": userR["token"],
            "u_ids": [user2R["auth_user_id"]],
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
        # ---------------------------
        # Message Send -------
        funcURL = "message/senddm/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": dmR["dm_id"],
            "message": "Hi",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        invalidToken = jwt.encode({"sessionId": 8}, database.secretSauce, algorithm="HS256")
        #checking message_share
        funcURL = "message/share/v1"
        inputData ={
            'token': invalidToken,
            'og_message_id': messageSendR["message_id"],
            'message': "",
            'channel_id': -1,
            'dm_id': dmR['dm_id'],
        }
        messageShare = requests.post(config.url + funcURL, json=inputData)
>       messageShareR = json.loads(messageShare.text)

http_tests/message_http_test.py:1422: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________________ testsendlater_too_long ____________________________

    def testsendlater_too_long():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message sendlater
        funcURL = "message/sendlater/v1"
        time = int(datetime.timestamp(datetime.now()) + 2)
        temp = 'x' * 2354
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": temp,
            "time_sent": time,
        }
        messageSendlater = requests.post(config.url + funcURL, json=inputData)
>       messageSendlaterR = json.loads(messageSendlater.text)

http_tests/message_http_test.py:1703: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Messages should be between 0 and 1000 characters long</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testsendlater_token_fail ___________________________

    def testsendlater_token_fail():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message sendlater
        funcURL = "message/sendlater/v1"
        time = int(datetime.timestamp(datetime.now()) + 2)
        invalid_token = jwt.encode({"sessionId": 9949}, database.secretSauce, algorithm = "HS256")
        inputData = {
            "token": invalid_token,
            "channel_id": channelR["channel_id"],
            "message": "Jonathan Chen and Thomas Qiu",
            "time_sent": time,
        }
        messageSendlater = requests.post(config.url + funcURL, json=inputData)
>       messageSendlaterR = json.loads(messageSendlater.text)

http_tests/message_http_test.py:1743: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ testsendlater_invalid_channel_id _______________________

    def testsendlater_invalid_channel_id():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(channel.text)
    
        # Message sendlater
        funcURL = "message/sendlater/v1"
        time = int(datetime.timestamp(datetime.now()) + 2)
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_id",
            "message": "Jonathan Chen and Thomas Qiu",
            "time_sent": time,
        }
        messageSendlater = requests.post(config.url + funcURL, json=inputData)
>       messageSendlaterR = json.loads(messageSendlater.text)

http_tests/message_http_test.py:1782: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testsendlater_empty_msg ____________________________

    def testsendlater_empty_msg():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message sendlater
        funcURL = "message/sendlater/v1"
        time = int(datetime.timestamp(datetime.now()) + 2)
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "",
            "time_sent": time,
        }
        messageSendlater = requests.post(config.url + funcURL, json=inputData)
        messageSendlaterR = json.loads(messageSendlater.text)
>       assert messageSendlaterR["code"] == 400
E       KeyError: 'code'

http_tests/message_http_test.py:1822: KeyError
______________________ testsendlater_user_not_in_channel _______________________

    def testsendlater_user_not_in_channel():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message sendlater
        funcURL = "message/sendlater/v1"
        time = int(datetime.timestamp(datetime.now()) + 2)
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
            "message": "Jonathan Chen and Thomas Qiu",
            "time_sent": time,
        }
        messageSendlater = requests.post(config.url + funcURL, json=inputData)
>       messageSendlaterR = json.loads(messageSendlater.text)

http_tests/message_http_test.py:1871: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>namefirstnamelast0 not a member of testchannel</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testsendlater_past_time ____________________________

    def testsendlater_past_time():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message sendlater
        funcURL = "message/sendlater/v1"
        time = int(datetime.timestamp(datetime.now()) - 2)
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Chenergy",
            "time_sent": time,
        }
        messageSendlater = requests.post(config.url + funcURL, json=inputData)
>       messageSendlaterR = json.loads(messageSendlater.text)

http_tests/message_http_test.py:1910: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Messages cannot postmarked</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testsendlaterdm_long_msg ___________________________

    def testsendlaterdm_long_msg():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Message sendlater
        funcURL = "message/sendlaterdm/v1"
        time = int(datetime.timestamp(datetime.now()) + 2)
        temp = 'x' * 2583
        inputData = {
            "token": user2R["token"],
            "dm_id": dmR["dm_id"],
            "message": temp,
            "time_sent": time,
        }
        messageSendlaterdm = requests.post(config.url + funcURL, json=inputData)
>       messageSendlaterdmR = json.loads(messageSendlaterdm.text)

http_tests/message_http_test.py:2033: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Messages should be between 0 and 1000 characters long</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ testsendlaterdm_wrong_token __________________________

    def testsendlaterdm_wrong_token():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Message sendlater
        funcURL = "message/sendlaterdm/v1"
        time = int(datetime.timestamp(datetime.now()) + 2)
        invalid_token = jwt.encode({"sessionId": 545999}, database.secretSauce, algorithm = "HS256")
        inputData = {
            "token": invalid_token,
            "dm_id": dmR["dm_id"],
            "message": "Thomas' DLore",
            "time_sent": time,
        }
        messageSendlaterdm = requests.post(config.url + funcURL, json=inputData)
>       messageSendlaterdmR = json.loads(messageSendlaterdm.text)

http_tests/message_http_test.py:2085: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ testsendlaterdm_wrong_dm_ID __________________________

    def testsendlaterdm_wrong_dm_ID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(dm.text)
    
        # Message sendlater
        funcURL = "message/sendlaterdm/v1"
        time = int(datetime.timestamp(datetime.now()) + 2)
        inputData = {
            "token": userR["token"],
            "dm_id": "invalid_id",
            "message": "Thomas' DLore",
            "time_sent": time,
        }
        messageSendlaterdm = requests.post(config.url + funcURL, json=inputData)
>       messageSendlaterdmR = json.loads(messageSendlaterdm.text)

http_tests/message_http_test.py:2136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________ testsendlaterdm_empty_msg ___________________________

    def testsendlaterdm_empty_msg():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Message sendlater
        funcURL = "message/sendlaterdm/v1"
        time = int(datetime.timestamp(datetime.now()) + 2)
        inputData = {
            "token": userR["token"],
            "dm_id": dmR["dm_id"],
            "message": "",
            "time_sent": time,
        }
        messageSendlaterdm = requests.post(config.url + funcURL, json=inputData)
        messageSendlaterdmR = json.loads(messageSendlaterdm.text)
>       assert messageSendlaterdmR["code"] == 400
E       KeyError: 'code'

http_tests/message_http_test.py:2188: KeyError
________________________ testsendlaterdm_user_not_found ________________________

    def testsendlaterdm_user_not_found():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Register Third Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Message sendlater
        funcURL = "message/sendlaterdm/v1"
        time = int(datetime.timestamp(datetime.now()) + 2)
        inputData = {
            "token": user3R["token"],
            "dm_id": dmR["dm_id"],
            "message": "Terry Crews",
            "time_sent": time,
        }
        messageSendlaterdm = requests.post(config.url + funcURL, json=inputData)
>       messageSendlaterdmR = json.loads(messageSendlaterdm.text)

http_tests/message_http_test.py:2249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>namefirstnamelast1 not a member of namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________ testsendlaterdm_past_time ___________________________

    def testsendlaterdm_past_time():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Message sendlater
        funcURL = "message/sendlaterdm/v1"
        time = int(datetime.timestamp(datetime.now()) - 2)
        inputData = {
            "token": userR["token"],
            "dm_id": dmR["dm_id"],
            "message": "Jake Perolta",
            "time_sent": time,
        }
        messageSendlaterdm = requests.post(config.url + funcURL, json=inputData)
>       messageSendlaterdmR = json.loads(messageSendlaterdm.text)

http_tests/message_http_test.py:2300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Messages cannot postmarked</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________ testreact_reacted_already ___________________________

    def testreact_reacted_already():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message React ----
        funcURL = "message/react/v1"
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
            "react_id": 1,
        }
        messageReact = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageReact.text)
    
    
        # Message React 2 ----
        funcURL = "message/react/v1"
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
            "react_id": 1,
        }
        messageReact2 = requests.post(config.url + funcURL, json=inputData)
>       messageReact2R = json.loads(messageReact2.text)

http_tests/message_http_test.py:2444: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Already reacted to this message</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ testunreact_unreacted_message _________________________

    def testunreact_unreacted_message():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message React ----
        funcURL = "message/react/v1"
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
            "react_id": 1,
        }
        messageReact = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageReact.text)
    
        # Message Unreact -----
        funcURL = "message/unreact/v1"
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
            "react_id": 1,
        }
        messageUnreact = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageUnreact.text)
    
        # Message Unreact 2 -----
        funcURL = "message/unreact/v1"
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
            "react_id": 1,
        }
        messageUnreact2 = requests.post(config.url + funcURL, json=inputData)
>       messageUnreact2R = json.loads(messageUnreact2.text)

http_tests/message_http_test.py:2591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Cannot unreact to a non-reacted message</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________________ testpin_pinned_already ____________________________

    def testpin_pinned_already():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Amy Santiago",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Pin --------
        funcURL = "message/pin/v1"
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
        }
        messagePin = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messagePin.text)
    
        # Message Pin --------
        funcURL = "message/pin/v1"
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
        }
        messagePin2 = requests.post(config.url + funcURL, json=inputData)
>       messagePin2R = json.loads(messagePin2.text)

http_tests/message_http_test.py:2755: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Message already pinned</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________ testunpin_unpinned_already __________________________

    def testunpin_unpinned_already():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Amy Santiago",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Pin --------
        funcURL = "message/pin/v1"
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
        }
        messagePin = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messagePin.text)
    
        # Message Unpin --------
        funcURL = "message/unpin/v1"
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
        }
        messageUnpin = requests.post(config.url + funcURL, json=inputData)
        messageUnpinR = json.loads(messageUnpin.text)
    
        # Message Unpin --------
        funcURL = "message/unpin/v1"
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
        }
        messageUnpin = requests.post(config.url + funcURL, json=inputData)
>       messageUnpinR = json.loads(messageUnpin.text)

http_tests/message_http_test.py:2892: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Message is not pinned</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________ test_http_notifications_invalid_token _____________________

    def test_http_notifications_invalid_token():
        requests.delete(config.url + "clear/v1")
    
        invalidToken = jwt.encode({"sessionId": 7}, "test", algorithm="HS256")
    
        funcURL = "notifications/get/v1"
        inputData = {
            "token": invalidToken
        }
        qData = urllib.parse.urlencode(inputData)
        rawResponseData = requests.get(config.url + funcURL + "?" + qData)
>       respD = json.loads(rawResponseData.text)

http_tests/notifications_http_test.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________________ test_http_clear_dm ______________________________

    def test_http_clear_dm():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
>       assert dmR == {
            'dm_id': 0,
            'dm_name': "namefirstnamelast, namefirstnamelast0"
        }
E       AssertionError: assert {'dm_id': 406, 'dm_name': 'namefirstnamelast, namefirstnamelast0'} == {'dm_id': 0, 'dm_name': 'namefirstnamelast, namefirstnamelast0'}
E         Common items:
E         {'dm_name': 'namefirstnamelast, namefirstnamelast0'}
E         Differing items:
E         {'dm_id': 406} != {'dm_id': 0}
E         Full diff:
E         - {'dm_id': 0, 'dm_name': 'namefirstnamelast, namefirstnamelast0'}
E         + {'dm_id': 406, 'dm_name': 'namefirstnamelast, namefirstnamelast0'}
E         ?           + +

http_tests/other_http_test.py:116: AssertionError
_____________________________ test_search_working ______________________________

    def test_search_working():
    
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Hello Guys",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Hello World",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Should not be seen in search",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Search
        funcURL = "search/v2"
        inputData = {
            "token": userR["token"],
            "query_str": "Hello",
        }
        qData = urllib.parse.urlencode(inputData)
        searchx = requests.get(config.url + funcURL + "?" + qData)
        searchxR = json.loads(searchx.text)
        search_list = searchxR["messages"]
    
>       assert search_list[0].get("message_id") == 1
E       assert 409 == 1
E         +409
E         -1

http_tests/other_http_test.py:201: AssertionError
__________________________ test_search_invalid_token ___________________________

    def test_search_invalid_token():
    
        requests.delete(config.url + "clear/v1")
        temp = jwt.encode({"sessionId": 7}, database.secretSauce, algorithm = "HS256")
    
        # Search
        funcURL = "search/v2"
        inputData = {
            "token": temp,
            "query_str": "Hello",
        }
        qData = urllib.parse.urlencode(inputData)
        searchx = requests.get(config.url + funcURL + "?" + qData)
>       searchxR = json.loads(searchx.text)

http_tests/other_http_test.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________ test_http_standup_invalid ___________________________

    def test_http_standup_invalid():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Start the standup in the channel
        # Standup Start -------
        funcURL = "standup/start/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "length": 2,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # Try to start a standup when there is already an active standup
        funcURL = "standup/start/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "length": 2,
        }
        standup2 = requests.post(config.url + funcURL, json=inputData)
>       standup2R = json.loads(standup2.text)

http_tests/standup_http_test.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Standup already active</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ test_http_standup_active_invalid _______________________

    def test_http_standup_active_invalid():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Start the standup in the channel
        # Standup Start -------
        funcURL = "standup/start/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "length": 2,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        invalid_channelId = 500
        # Standup Active
        funcURL = "standup/active/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": invalid_channelId,
        }
        qData = urllib.parse.urlencode(inputData)
        standupActive = requests.get(config.url + funcURL + "?" + qData)
>       standupActiveR = json.loads(standupActive.text)

http_tests/standup_http_test.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>500 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ test_http_standup_send_invalid ________________________

    def test_http_standup_send_invalid():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "Hayden",
            "name_last": "Smith",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Start the standup in the channel
        # Standup Start -------
        funcURL = "standup/start/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "length": 2,
        }
        standup = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(standup.text)
    
        # If it is not none therefore a time has been generated for the standup
        # I.e. it is existing
    
        # Message Send -------
        funcURL = "standup/send/v1"
    
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "a" * 1001,
        }
        standupSend = requests.post(config.url + funcURL, json=inputData)
>       standupSendR = json.loads(standupSend.text)

http_tests/standup_http_test.py:366: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Messages should be between 0 and 1000 characters long</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ test_http_user_profile_working ________________________

    def test_http_user_profile_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQzMSwibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6ImQxY2EzODUxLTc3NTUtNDFlMi05YzBmLWZhOGI4ZjA2MzkzNiJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'W"\xc7*\xf0\xc1\xba\xdcg\xbf{\xd4\x10\x07q\x94Yn\xdc`\x93\xb7\xac\xbe\x02\x87\xeeQ\x7f\x87\x01\x88'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
__________________ test_http_user_profile_v2_nonexistant_user __________________

    def test_http_user_profile_v2_nonexistant_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQzMiwibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6IjRiMTk2NWViLWIwMTUtNGUzMS1hZjFjLTBmYjU2YzcxYzYwYiJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\x8a\xb3\xef\x99_\xe9\xb0\x87\xcaV\xc2\xfc\xda\x8d\xbd\x11\x93\x9e\xe2\x12 \x85\x1a}\xd7\r\xdc\xc6\x02\x01\xc3J'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
______________________ test_user_profile_setname_working _______________________

    def test_user_profile_setname_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQzMywibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6ImU5ZDJiY2E0LWRlNGItNDc0Yi05OTMwLWYwZWM1ODYyMzE3ZiJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xe1T\xaa\xc8\xef\xc4\xe6\x1f\xd0\x04oc\x89\xf9g\x15\xe6\xe9\x99\xb9n@\xcf\t6\xa1\xd5\xb4\x07B>\xc6'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
__________________ test_http_user_profile_setname_short_first __________________

    def test_http_user_profile_setname_short_first():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQzNCwibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6IjMxM2U3MGJkLTQyMzAtNDFlMC04MDIyLWYxMWRhMWRmM2IwNCJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xa42\x94\x1d\xc8D\x0eM\x07\x1e\xce\xbf\x9d\xd5\x03p\xe5\xa5\xe5\x00\x9b\x97\x02\x14\xeb\xe5\x96\x05 \xd2\x15\xa8'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
__________________ test_http_user_profile_setname_short_last ___________________

    def test_http_user_profile_setname_short_last():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQzNSwibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6IjBlMWE4YTVmLWJlOWItNDVjOS1iZWJhLTkwMmQwNDU0MDhlYyJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'aaoTG+\xcet9B\xef\x0e9\x89.1\x96=x\xba\x00\xc4\xaf\xe7y\r\xb3\xc4\xa5a\xbf\x81'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
__________________ test_http_user_profile_setname_long_first ___________________

    def test_http_user_profile_setname_long_first():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:203: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQzNiwibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6IjdhM2E4YWU0LTQ3ZGItNGE1Ny05YWJlLTI3MzUyNmJjYjNhZSJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'yPE\xe1\xfa\xb4L~\xf2\xfd/Pl\x0eE\x9ds\x9f\xb7\x93\xf5\xffQ\x93V\xb6\xfc\x9c\xaax`M'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
___________________ test_http_user_profile_setname_long_last ___________________

    def test_http_user_profile_setname_long_last():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQzNywibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6ImQwMjNkMGVhLTdmYzEtNGJmZS1iOWZkLTQ1MzUzOTE0MjE2OSJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b')\xf2\xc1[\x90\xd9m=\xec\x8dX\xe7\xd1\x8b\xd7/Del7U\xf11\x04as\xe7\xd5f\x8d\x15w'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
___________________ test_http_user_profile_setemail_working ____________________

    def test_http_user_profile_setemail_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQzOCwibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6ImJjZjMzNGM2LWM5ZGUtNDI5ZC1hMTQwLTIwMDFlMzA3OTVjMSJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xf0;n9\xd9N\xf7\x0c\xa9\xf5\x99\xf8~\xaf\xd3\x00T\xb8\x0e\xb0$d\xd6\xc4\x83\xc8\x016<\xdb\xcc\x13'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
________________ test_http_user_profile_setemail_invalid_email _________________

    def test_http_user_profile_setemail_invalid_email():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQzOSwibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6IjdjYjNlMDBlLTE2MWEtNDdiMS05ZTY2LTI1ZTQ1ZTU0NWY5NCJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xfb\xf2\xd0?\x1e\xd3\xa3\x03\xb4\x8e\xd4\xfa\x00\xcbK\x0e\xbd\xbe\xff\xb1\xa8J\xd3\x1aI\x1fwO\x8f\x13\xe6\x1c'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
_________________ test_http_user_profile_setemail_email_taken __________________

    def test_http_user_profile_setemail_email_taken():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQ0MCwibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6ImVjNjRiZTdiLTExOGUtNDRhMy04MTEzLWI1NzY1NzMyZTQ2ZiJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xa2\x9d\xba\x99\x956o\t\xcf\xdd\xa5\x0f\xa5\xa7k\xe6k1\xac<ov\x95h\xf4\xee\xff\xe8\xb6\xa3d)'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
___________________ test_http_user_profile_sethandle_working ___________________

    def test_http_user_profile_sethandle_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:389: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQ0MSwibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6IjExZTMxMWNjLWI4MDktNGMyZC05Mjk1LTI1MjEzNmZiNDUzYSJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\x16\xc6\t\xbe\x1b\xde\x1b\x18\xad\xe7\xee-\xf83\xe27\x04\x0e\xc0\xa2"J\x1ev41\x05?\xb5t[)'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
________________ test_http_user_profile_sethandle_short_handle _________________

    def test_http_user_profile_sethandle_short_handle():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQ0MiwibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6IjljMGZlNGQwLTJmNjctNDczNC1iOWUwLTRjYTRmNzkwZDNlNCJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'v\xd8\xcb\xc6\xc9}y\x90P\x8d\xc6\xc8\xbe\xcc\x85\xb4g9\x98\x11\x07A\xe6\xbe\xdb\x91U=\x04\x1b\xd3g'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
_________________ test_http_user_profile_sethandle_long_handle _________________

    def test_http_user_profile_sethandle_long_handle():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:468: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQ0MywibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6IjhjOWIyYmE2LWZiMzctNDFkYS1iYTIwLWViZDI1ODM3ZmZlNSJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xfe\xa9]\xb5\x9c-\x1a\x96\xff\x08.m\x8dZ\xa8\xfb\x15bu\x00\xb2Z zW\xb3R\x08\x12L\xa3\n'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
________________ test_http_user_profile_sethandle_handle_taken _________________

    def test_http_user_profile_sethandle_handle_taken():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password2",
            "name_first": "name2First",
            "name_last": "name2Last",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:508: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQ0NSwibG9naW5fdGltZSI6MTYxODk1MTM3NCwic2FsdCI6ImM4YjMwZDI1LWExMjktNGU4NC05NTJhLTMwYTdiOGY4OTEyZSJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\x97\xbbO\xd1\xa1S\x0b\x85\xfe\x07\x0bY\x02\xe0f;Yl1a\xea\x07\xd7\xec\x08U\x11{\xdd+T\xcb'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
_________________________ test_http_users_all_working __________________________

    def test_http_users_all_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        u_id1 = respD["auth_user_id"]
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password2",
            "name_first": "name2First",
            "name_last": "name2Last",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:552: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7f4780ac4908>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQ0NywibG9naW5fdGltZSI6MTYxODk1MTM3NSwic2FsdCI6IjAxNTVmMWYzLWU3M2ItNDE4NC1hODUxLTgyYzRlZDg3YTYzOSJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\x13:\xa3n\xbb\xdd\xbe\x81\x1a\x8c\xdd\xb0@\xf7\x13\xb8\xd3\xbc\xe6X(\xf7\xaa\x92t_y\x92\xf0\xbc\x968'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
_________________________ test_http_user_stats_working _________________________

    def test_http_user_stats_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        u_id1 = respD["auth_user_id"]
        token1 = respD["token"]
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": token1,
            "name": "testchannel",
            "is_public": True,
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        # ----------------------------
    
        # User Profile ---------------
        funcURL = "user/profile/v2"
        inputData = {
            "token": token1,
            "u_id": u_id1
        }
        qData = urllib.parse.urlencode(inputData)
        rawResponseData = requests.get(config.url + funcURL + "?" + qData)
        respD = json.loads(rawResponseData.text)
        #-----------------------------
        funcURL = "user/stats/v1"
        inputData = {
            "token": token1
        }
        qData = urllib.parse.urlencode(inputData)
        rawResponseData = requests.get(config.url + funcURL + "?" + qData)
        respD = json.loads(rawResponseData.text)
    
        expectedOutput = {
            "channels_joined": [{
                "num_channels_joined": 1,
                "time_stamp": respD["user_stats"]["channels_joined"][0]["time_stamp"],
            }],
            "dms_joined": [{
                "num_dms_joined": 0,
                "time_stamp": respD["user_stats"]["channels_joined"][0]["time_stamp"],
            }],
            "messages_sent": [{
                "num_messages_sent": 0,
                "time_stamp": respD["user_stats"]["channels_joined"][0]["time_stamp"],
            }],
            "involvement_rate": 1.0,
        }
    
>       assert respD["user_stats"] == expectedOutput
E       AssertionError: assert {'channels_joined': [{'num_channels_joined': 0, 'time_stamp': 1618951375},\n                     {'num_channels_joined': 1, 'time_stamp': 1618951375}],\n 'dms_joined': [{'num_dms_joined': 0, 'time_stamp': 1618951375}],\n 'involvement_rate': 1.0,\n 'messages_sent': [{'num_messages_sent': 0, 'time_stamp': 1618951375}]} == {'channels_joined': [{'num_channels_joined': 1, 'time_stamp': 1618951375}],\n 'dms_joined': [{'num_dms_joined': 0, 'time_stamp': 1618951375}],\n 'involvement_rate': 1.0,\n 'messages_sent': [{'num_messages_sent': 0, 'time_stamp': 1618951375}]}
E         Common items:
E         {'dms_joined': [{'num_dms_joined': 0, 'time_stamp': 1618951375}],
E          'involvement_rate': 1.0,
E          'messages_sent': [{'num_messages_sent': 0, 'time_stamp': 1618951375}]}
E         Differing items:
E         {'channels_joined': [{'num_channels_joined': 0, 'time_stamp': 1618951375}, {'num_channels_joined': 1, 'time_stamp': 1618951375}]} != {'channels_joined': [{'num_channels_joined': 1, 'time_stamp': 1618951375}]}
E         Full diff:
E           {
E         -  'channels_joined': [{'num_channels_joined': 1,
E         ?                                              ^
E         +  'channels_joined': [{'num_channels_joined': 0,
E         ?                                              ^
E         +                       'time_stamp': 1618951375},
E         +                      {'num_channels_joined': 1,
E                                 'time_stamp': 1618951375}],
E            'dms_joined': [{'num_dms_joined': 0,
E                            'time_stamp': 1618951375}],
E            'involvement_rate': 1.0,
E            'messages_sent': [{'num_messages_sent': 0,
E                               'time_stamp': 1618951375}],
E           }

http_tests/user_http_test.py:648: AssertionError
________________________ test_http_users_stats_working _________________________

    def test_http_users_stats_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        u_id1 = respD["auth_user_id"]
        token1 = respD["token"]
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": token1,
            "name": "testchannel",
            "is_public": True,
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        # ----------------------------
    
        # User Profile ---------------
        funcURL = "user/profile/v2"
        inputData = {
            "token": token1,
            "u_id": u_id1
        }
        qData = urllib.parse.urlencode(inputData)
        rawResponseData = requests.get(config.url + funcURL + "?" + qData)
        respD = json.loads(rawResponseData.text)
        #-----------------------------
    
        funcURL = "users/stats/v1"
        inputData = {
            "token": token1,
        }
        qData = urllib.parse.urlencode(inputData)
        rawResponseData = requests.get(config.url + funcURL + "?" + qData)
>       respD = json.loads(rawResponseData.text)

http_tests/user_http_test.py:697: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7f478176b518>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
=========================== short test summary info ============================
FAILED http_tests/admin_http_test.py::test_http_admin_user_remove_u_id_does_not_exist
FAILED http_tests/admin_http_test.py::test_http_admin_user_remove_auth_not_owner
FAILED http_tests/admin_http_test.py::test_http_admin_user_remove_auth_only_owner
FAILED http_tests/admin_http_test.py::test_http_admin_userpermission_u_id_does_not_exist
FAILED http_tests/admin_http_test.py::test_http_admin_userpermission_permission_id_not_valid
FAILED http_tests/admin_http_test.py::test_http_admin_userpermission_auth_not_owner
FAILED http_tests/admin_http_test.py::test_http_admin_user_remove_u_id_does_not_exist
FAILED http_tests/admin_http_test.py::test_http_admin_user_remove_auth_not_owner
FAILED http_tests/admin_http_test.py::test_http_admin_user_remove_auth_only_owner
FAILED http_tests/admin_http_test.py::test_http_admin_userpermission_u_id_does_not_exist
FAILED http_tests/admin_http_test.py::test_http_admin_userpermission_permission_id_not_valid
FAILED http_tests/admin_http_test.py::test_http_admin_userpermission_auth_not_owner
FAILED http_tests/auth_http_test.py::test_http_auth_register_already_registered_email
FAILED http_tests/auth_http_test.py::test_http_auth_register_invalid_email - ...
FAILED http_tests/auth_http_test.py::test_http_auth_register_short_first - js...
FAILED http_tests/auth_http_test.py::test_http_auth_register_short_last - jso...
FAILED http_tests/auth_http_test.py::test_http_auth_register_long_first - jso...
FAILED http_tests/auth_http_test.py::test_http_auth_register_long_last - json...
FAILED http_tests/auth_http_test.py::test_http_auth_login_invalid_email - jso...
FAILED http_tests/auth_http_test.py::test_http_auth_login_unregistered_email
FAILED http_tests/auth_http_test.py::test_http_auth_login_incorrect_password
FAILED http_tests/auth_http_test.py::test_http_logout_invalid_token_key - jso...
FAILED http_tests/auth_http_test.py::test_http_logout_invalid_token_value - j...
FAILED http_tests/auth_http_test.py::test_http_logout_invalid_token_type - js...
FAILED http_tests/auth_http_test.py::test_http_logout_nonexistant_user - json...
FAILED http_tests/auth_http_test.py::test_http_passwordreset_request_invalid_email
FAILED http_tests/auth_http_test.py::test_http_passwordreset_reset_invalid_code
FAILED http_tests/auth_http_test.py::test_http_passwordreset_reset_invalid_password
FAILED http_tests/channel_http_test.py::testjoin_invalid_channelID - json.dec...
FAILED http_tests/channel_http_test.py::testjoin_invalid_tokenn - json.decode...
FAILED http_tests/channel_http_test.py::testjoin_joined_already - json.decode...
FAILED http_tests/channel_http_test.py::testjoin_private_channel - json.decod...
FAILED http_tests/channel_http_test.py::testjoin_already_joined - json.decode...
FAILED http_tests/channel_http_test.py::testjoin_valid_case - AssertionError:...
FAILED http_tests/channel_http_test.py::testaddowner_invalid_tokenn - json.de...
FAILED http_tests/channel_http_test.py::testaddowner_invalid_uID - json.decod...
FAILED http_tests/channel_http_test.py::testaddowner_invalid_channelID - json...
FAILED http_tests/channel_http_test.py::testaddowner_already_owner - json.dec...
FAILED http_tests/channel_http_test.py::testaddowner_unauthorised_token - jso...
FAILED http_tests/channel_http_test.py::testaddowner_not_in_channel - KeyErro...
FAILED http_tests/channel_http_test.py::test_http_channel_removeowner_invalid_user
FAILED http_tests/channel_http_test.py::test_http_channel_removeowner_invalid_channel
FAILED http_tests/channel_http_test.py::test_http_channel_removeowner_only_owner
FAILED http_tests/channel_http_test.py::test_http_channel_removeowner_not_owner
FAILED http_tests/channel_http_test.py::test_http_channel_removeowner_invalid_token
FAILED http_tests/channel_http_test.py::test_http_channel_leave_channel_valid
FAILED http_tests/channel_http_test.py::test_http_channel_leave_user_valid - ...
FAILED http_tests/channel_http_test.py::test_http_channel_messages_working - ...
FAILED http_tests/channel_http_test.py::test_http_channel_messages_invalid_channel
FAILED http_tests/channel_http_test.py::test_http_channel_messages_startgreater
FAILED http_tests/channel_http_test.py::test_http_channel_messages_not_authorised
FAILED http_tests/channels_http_test.py::test_http_channels_create_working - ...
FAILED http_tests/channels_http_test.py::test_http_channels_create_multiple
FAILED http_tests/channels_http_test.py::test_http_channels_create_invalid_token
FAILED http_tests/channels_http_test.py::test_http_channels_create_longer_than_twenty_char
FAILED http_tests/channels_http_test.py::test_http_channels_list_working - As...
FAILED http_tests/channels_http_test.py::test_http_channels_list_invalid_user
FAILED http_tests/channels_http_test.py::test_http_channels_listall_invalid_user
FAILED http_tests/dm_http_test.py::test_http_dm_create_working - AssertionErr...
FAILED http_tests/dm_http_test.py::test_http_dm_create_invalid_user - json.de...
FAILED http_tests/dm_http_test.py::test_http_dm_create_invalid_token - json.d...
FAILED http_tests/dm_http_test.py::test_http_dm_invite_working - AssertionErr...
FAILED http_tests/dm_http_test.py::test_http_dm_invite_invalid_dmid - json.de...
FAILED http_tests/dm_http_test.py::test_http_dm_invite_invalid_uid - json.dec...
FAILED http_tests/dm_http_test.py::test_http_dm_inviter_not_in_dm - json.deco...
FAILED http_tests/dm_http_test.py::test_http_dm_list_working - AssertionError...
FAILED http_tests/dm_http_test.py::test_http_dm_list_invalid_token - json.dec...
FAILED http_tests/dm_http_test.py::test_http_dm_leave_invalid_dm - json.decod...
FAILED http_tests/dm_http_test.py::test_http_dm_leave_unauthorized_user - jso...
FAILED http_tests/dm_http_test.py::test_http_dm_leave_invalid_token - json.de...
FAILED http_tests/dm_http_test.py::test_http_dm_remove_invalid_id - json.deco...
FAILED http_tests/dm_http_test.py::test_http_dm_remove_not_owner - json.decod...
FAILED http_tests/dm_http_test.py::test_http_dm_remove_invalid_token - json.d...
FAILED http_tests/dm_http_test.py::test_http_dm_message_invalid_user - json.d...
FAILED http_tests/dm_http_test.py::test_http_dm_message_invalid_dm - json.dec...
FAILED http_tests/dm_http_test.py::test_http_dm_message_unauthorised_user - j...
FAILED http_tests/dm_http_test.py::test_http_dm_message_startgreater - json.d...
FAILED http_tests/dm_http_test.py::test_http_dm_details_dm_does_not_exist - j...
FAILED http_tests/dm_http_test.py::test_http_dm_details_user_not_member_of_dm
FAILED http_tests/echo_http_test.py::test_echo - json.decoder.JSONDecodeError...
FAILED http_tests/message_http_test.py::testsend_empty_message - KeyError: 'c...
FAILED http_tests/message_http_test.py::testsend_invalid_long_msg - json.deco...
FAILED http_tests/message_http_test.py::testsend_invalid_token - json.decoder...
FAILED http_tests/message_http_test.py::testsend_invalid_channel - json.decod...
FAILED http_tests/message_http_test.py::testsend_sent_not_in_channel - json.d...
FAILED http_tests/message_http_test.py::testsend_valid_case - assert 242 == 1
FAILED http_tests/message_http_test.py::testedit_invalid_long_msg - json.deco...
FAILED http_tests/message_http_test.py::testedit_invalid_token - json.decoder...
FAILED http_tests/message_http_test.py::testedit_invalid_mID - json.decoder.J...
FAILED http_tests/message_http_test.py::testedit_not_authorised - json.decode...
FAILED http_tests/message_http_test.py::testedit_valid_case - assert 258 == 1
FAILED http_tests/message_http_test.py::testedit_comprehensive_valid - assert...
FAILED http_tests/message_http_test.py::testremove_invalid_token_id - json.de...
FAILED http_tests/message_http_test.py::testremove_invalid_mID - json.decoder...
FAILED http_tests/message_http_test.py::testremove_empty - json.decoder.JSOND...
FAILED http_tests/message_http_test.py::testremove_unauthorised - json.decode...
FAILED http_tests/message_http_test.py::testsenddm_invalid_empty_message - Ke...
FAILED http_tests/message_http_test.py::testsenddm_invalid_long_msg - json.de...
FAILED http_tests/message_http_test.py::testsenddm_invalid_token_ID - json.de...
FAILED http_tests/message_http_test.py::testsenddm_invalid_dmID - json.decode...
FAILED http_tests/message_http_test.py::testsenddm_unauthorised_user - json.d...
FAILED http_tests/message_http_test.py::testsenddm_valid_case - assert 301 == 1
FAILED http_tests/message_http_test.py::test_http_message_share_not_member_of_channel_sharing_to
FAILED http_tests/message_http_test.py::test_http_message_share_not_member_of_dm_sharing_to
FAILED http_tests/message_http_test.py::testsendlater_too_long - json.decoder...
FAILED http_tests/message_http_test.py::testsendlater_token_fail - json.decod...
FAILED http_tests/message_http_test.py::testsendlater_invalid_channel_id - js...
FAILED http_tests/message_http_test.py::testsendlater_empty_msg - KeyError: '...
FAILED http_tests/message_http_test.py::testsendlater_user_not_in_channel - j...
FAILED http_tests/message_http_test.py::testsendlater_past_time - json.decode...
FAILED http_tests/message_http_test.py::testsendlaterdm_long_msg - json.decod...
FAILED http_tests/message_http_test.py::testsendlaterdm_wrong_token - json.de...
FAILED http_tests/message_http_test.py::testsendlaterdm_wrong_dm_ID - json.de...
FAILED http_tests/message_http_test.py::testsendlaterdm_empty_msg - KeyError:...
FAILED http_tests/message_http_test.py::testsendlaterdm_user_not_found - json...
FAILED http_tests/message_http_test.py::testsendlaterdm_past_time - json.deco...
FAILED http_tests/message_http_test.py::testreact_reacted_already - json.deco...
FAILED http_tests/message_http_test.py::testunreact_unreacted_message - json....
FAILED http_tests/message_http_test.py::testpin_pinned_already - json.decoder...
FAILED http_tests/message_http_test.py::testunpin_unpinned_already - json.dec...
FAILED http_tests/notifications_http_test.py::test_http_notifications_invalid_token
FAILED http_tests/other_http_test.py::test_http_clear_dm - AssertionError: as...
FAILED http_tests/other_http_test.py::test_search_working - assert 409 == 1
FAILED http_tests/other_http_test.py::test_search_invalid_token - json.decode...
FAILED http_tests/standup_http_test.py::test_http_standup_invalid - json.deco...
FAILED http_tests/standup_http_test.py::test_http_standup_active_invalid - js...
FAILED http_tests/standup_http_test.py::test_http_standup_send_invalid - json...
FAILED http_tests/user_http_test.py::test_http_user_profile_working - jwt.exc...
FAILED http_tests/user_http_test.py::test_http_user_profile_v2_nonexistant_user
FAILED http_tests/user_http_test.py::test_user_profile_setname_working - jwt....
FAILED http_tests/user_http_test.py::test_http_user_profile_setname_short_first
FAILED http_tests/user_http_test.py::test_http_user_profile_setname_short_last
FAILED http_tests/user_http_test.py::test_http_user_profile_setname_long_first
FAILED http_tests/user_http_test.py::test_http_user_profile_setname_long_last
FAILED http_tests/user_http_test.py::test_http_user_profile_setemail_working
FAILED http_tests/user_http_test.py::test_http_user_profile_setemail_invalid_email
FAILED http_tests/user_http_test.py::test_http_user_profile_setemail_email_taken
FAILED http_tests/user_http_test.py::test_http_user_profile_sethandle_working
FAILED http_tests/user_http_test.py::test_http_user_profile_sethandle_short_handle
FAILED http_tests/user_http_test.py::test_http_user_profile_sethandle_long_handle
FAILED http_tests/user_http_test.py::test_http_user_profile_sethandle_handle_taken
FAILED http_tests/user_http_test.py::test_http_users_all_working - jwt.except...
FAILED http_tests/user_http_test.py::test_http_user_stats_working - Assertion...
FAILED http_tests/user_http_test.py::test_http_users_stats_working - json.dec...
======================= 144 failed, 39 passed in 27.52s ========================
