============================= test session starts ==============================
platform linux -- Python 3.7.3, pytest-6.2.3, py-1.10.0, pluggy-0.13.1
rootdir: /tmp_amd/kamen/export/kamen/3/cs1531/automark/tempstore, configfile: pytest.ini
plugins: forked-1.3.0, xdist-2.2.1, hypothesis-6.1.1, timeout-1.4.2
collected 147 items

http_tests/admin_http_test.py FFF.FFF..FFF.FFF..                         [  6%]
http_tests/auth_http_test.py .FFFFFF.FFFFFFFF                            [ 17%]
http_tests/channel_http_test.py FFFFFFFFFFFFF.FFFFF.FFFFFF.              [ 35%]
http_tests/channels_http_test.py FFFFFF.F                                [ 40%]
http_tests/dm_http_test.py FFFFFFFFFFFFFFFFFFFFFFFFFF                    [ 58%]
http_tests/echo_http_test.py F                                           [ 59%]
http_tests/message_http_test.py FFFFFFFFFFFFFFFFF..FFFFFFFF....          [ 80%]
http_tests/other_http_test.py ..FFF                                      [ 83%]
http_tests/user_http_test.py FFFFFFFFFFFFFFF

=================================== FAILURES ===================================
_______________ test_http_admin_user_remove_u_id_does_not_exist ________________

    def test_http_admin_user_remove_u_id_does_not_exist():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
        # ----------------------------
        #chec admin user remove
        funcURL = "admin/user/remove/v1"
        inputData ={
            "token": userR['token'],
            "u_id": 3
        }
        adminUserRemove = requests.delete(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>3 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________ test_http_admin_user_remove_auth_not_owner __________________

    def test_http_admin_user_remove_auth_not_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------------
        #check admin user remove
        funcURL = "admin/user/remove/v1"
        inputData ={
            "token": user2R['token'],
            "u_id": user3R['auth_user_id']
        }
        adminUserRemove = requests.delete(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Only owners can remove members</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________ test_http_admin_user_remove_auth_only_owner __________________

    def test_http_admin_user_remove_auth_only_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        #check admin user remove
        funcURL = "admin/user/remove/v1"
        inputData ={
            "token": userR['token'],
            "u_id": userR['auth_user_id']
        }
        adminUserRemove = requests.delete(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Cannot remove last owner</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________ test_http_admin_userpermission_u_id_does_not_exist ______________

    def test_http_admin_userpermission_u_id_does_not_exist():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmai.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
        # ----------------------------
        #chec admin user permission
        funcURL = "admin/userpermission/change/v1"
        inputData ={
            "token": userR['token'],
            "u_id": 3,
            "permission_id": 1
        }
        adminUserPermission = requests.post(config.url + funcURL, json=inputData)
>       adminUserPermissionR = json.loads(adminUserPermission.text)

http_tests/admin_http_test.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>3 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________ test_http_admin_userpermission_permission_id_not_valid ____________

    def test_http_admin_userpermission_permission_id_not_valid():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmai.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        #check admin user permission
        funcURL = "admin/userpermission/change/v1"
        inputData ={
            "token": userR['token'],
            "u_id": user2R['auth_user_id'],
            "permission_id": 5
        }
        adminUserPermission = requests.post(config.url + funcURL, json=inputData)
>       adminUserPermissionR = json.loads(adminUserPermission.text)

http_tests/admin_http_test.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Invalid permission ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________ test_http_admin_userpermission_auth_not_owner _________________

    def test_http_admin_userpermission_auth_not_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------------
        #check admin user rpermssion
        funcURL = "admin/userpermission/change/v1"
        inputData ={
            "token": user2R['token'],
            "u_id": user3R['auth_user_id'],
            "permission_id": 1
    
        }
        adminUserRemove = requests.post(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Only owners can modify permissions</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________ test_http_admin_user_remove_u_id_does_not_exist ________________

    def test_http_admin_user_remove_u_id_does_not_exist():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
        # ----------------------------
        #chec admin user remove
        funcURL = "admin/user/remove/v1"
        inputData ={
            "token": userR['token'],
            "u_id": 3
        }
        adminUserRemove = requests.delete(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>3 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________ test_http_admin_user_remove_auth_not_owner __________________

    def test_http_admin_user_remove_auth_not_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------------
        #check admin user remove
        funcURL = "admin/user/remove/v1"
        inputData ={
            "token": user2R['token'],
            "u_id": user3R['auth_user_id']
        }
        adminUserRemove = requests.delete(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Only owners can remove members</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________ test_http_admin_user_remove_auth_only_owner __________________

    def test_http_admin_user_remove_auth_only_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        #check admin user remove
        funcURL = "admin/user/remove/v1"
        inputData ={
            "token": userR['token'],
            "u_id": userR['auth_user_id']
        }
        adminUserRemove = requests.delete(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Cannot remove last owner</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________ test_http_admin_userpermission_u_id_does_not_exist ______________

    def test_http_admin_userpermission_u_id_does_not_exist():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmai.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
        # ----------------------------
        #chec admin user permission
        funcURL = "admin/userpermission/change/v1"
        inputData ={
            "token": userR['token'],
            "u_id": 3,
            "permission_id": 1
        }
        adminUserPermission = requests.post(config.url + funcURL, json=inputData)
>       adminUserPermissionR = json.loads(adminUserPermission.text)

http_tests/admin_http_test.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>3 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________ test_http_admin_userpermission_permission_id_not_valid ____________

    def test_http_admin_userpermission_permission_id_not_valid():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmai.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        #check admin user permission
        funcURL = "admin/userpermission/change/v1"
        inputData ={
            "token": userR['token'],
            "u_id": user2R['auth_user_id'],
            "permission_id": 5
        }
        adminUserPermission = requests.post(config.url + funcURL, json=inputData)
>       adminUserPermissionR = json.loads(adminUserPermission.text)

http_tests/admin_http_test.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Invalid permission ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________ test_http_admin_userpermission_auth_not_owner _________________

    def test_http_admin_userpermission_auth_not_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------------
        #check admin user rpermssion
        funcURL = "admin/userpermission/change/v1"
        inputData ={
            "token": user2R['token'],
            "u_id": user3R['auth_user_id'],
            "permission_id": 1
    
        }
        adminUserRemove = requests.post(config.url + funcURL, json=inputData)
>       adminUserRemoveR = json.loads(adminUserRemove.text)

http_tests/admin_http_test.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Only owners can modify permissions</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________ test_http_auth_register_already_registered_email _______________

    def test_http_auth_register_already_registered_email():
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>test@hotmail.com already taken</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________ test_http_auth_register_invalid_email _____________________

    def test_http_auth_register_invalid_email():
        requests.delete(config.url + "clear/v1")
    
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email is invalid</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________ test_http_auth_register_short_first ______________________

    def test_http_auth_register_short_first():
        requests.delete(config.url + "clear/v1")
    
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password1",
            "name_first": "",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email is invalid</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_auth_register_short_last ______________________

    def test_http_auth_register_short_last():
        requests.delete(config.url + "clear/v1")
    
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email is invalid</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_auth_register_long_first ______________________

    def test_http_auth_register_long_first():
        requests.delete(config.url + "clear/v1")
    
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password1",
            "name_first": "nameFirst" * 15,
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email is invalid</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_auth_register_long_last _______________________

    def test_http_auth_register_long_last():
        requests.delete(config.url + "clear/v1")
    
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast" * 15,
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email is invalid</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_auth_login_invalid_email ______________________

    def test_http_auth_login_invalid_email():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/login/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password1",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       testOutput = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email or password is incorrect</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________ test_http_auth_login_unregistered_email ____________________

    def test_http_auth_login_unregistered_email():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/login/v2"
        inputData = {
            "email": "unregistered@hotmail.com",
            "password": "password1",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       testOutput = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email or password is incorrect</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________ test_http_auth_login_incorrect_password ____________________

    def test_http_auth_login_incorrect_password():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/login/v2"
        inputData = {
            "email": "test@hotmail.com.au",
            "password": "password",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       testOutput = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Email or password is incorrect</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ test_http_logout_working ___________________________

    def test_http_logout_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       token = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/auth_http_test.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjQ4LCJsb2dpbl90aW1lIjoxNjE5MTg2NTExLCJzYWx0IjoiOWUzNjUwYWQtOTgyMy00OGM2LTlkZTQtN2ZiNjc0NzBjYzUyIn0'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b"F\x11v*'\x1d\xad\xc7+\r\xef[\xea\x0c\xf4j\xf1_\xf8\x1d\xd5aVy\xa9\x9c\x80\xb5\xb2\x157\xe3"
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
______________________ test_http_logout_invalid_token_key ______________________

    def test_http_logout_invalid_token_key():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/logout/v1"
        inputData = jwt.encode({"invalidKey": 6}, database.secretSauce, algorithm="HS256")
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________ test_http_logout_invalid_token_value _____________________

    def test_http_logout_invalid_token_value():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/logout/v1"
        inputData = jwt.encode({"sessionId": "notAnInt"}, database.secretSauce, algorithm="HS256")
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________ test_http_logout_invalid_token_type ______________________

    def test_http_logout_invalid_token_type():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/logout/v1"
        inputData = jwt.encode({"invalidKey": 9999}, database.secretSauce, algorithm="HS256")
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_logout_nonexistant_user _______________________

    def test_http_logout_nonexistant_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        funcURL = "auth/logout/v1"
        inputData = jwt.encode({"sessionId": -99999}, database.secretSauce, algorithm="HS256")
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
>       respD = json.loads(rawResponseData.text)

http_tests/auth_http_test.py:327: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________ testjoin_invalid_channelID __________________________

    def testjoin_invalid_channelID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(channel.text)
    
        # Channel Join -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_id",
        }
        join = requests.post(config.url + funcURL, json=inputData)
>       joinR = json.loads(join.text)

http_tests/channel_http_test.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testjoin_invalid_tokenn ____________________________

    def testjoin_invalid_tokenn():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join -------
        funcURL = "channel/join/v2"
        temp = jwt.encode({"sessionId": 2000}, database.secretSauce, algorithm = "HS256")
        inputData = {
            "token": temp,
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
>       joinR = json.loads(join.text)

http_tests/channel_http_test.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testjoin_joined_already ____________________________

    def testjoin_joined_already():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(join.text)
    
        # Channel Join Error -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        join2 = requests.post(config.url + funcURL, json=inputData)
>       join2R = json.loads(join2.text)

http_tests/channel_http_test.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast0 is already a member of testchannel</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testjoin_private_channel ___________________________

    def testjoin_private_channel():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": False,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
>       joinR = json.loads(join.text)

http_tests/channel_http_test.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>You don\'t have permission to join this channel</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testjoin_already_joined ____________________________

    def testjoin_already_joined():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": False,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
>       joinR = json.loads(join.text)

http_tests/channel_http_test.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of testchannel</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________________ testjoin_valid_case ______________________________

    def testjoin_valid_case():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Register Third Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join (Second Person) -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(join.text)
    
        # Channel Join (Third Person) -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user3R["token"],
            "channel_id": channelR["channel_id"],
        }
        join2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(join2.text)
    
        # Channel Details
        funcURL = "channel/details/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
        }
        qData = urllib.parse.urlencode(inputData)
        channelDetails = requests.get(config.url + funcURL + "?" + qData)
        channelDetailsR = json.loads(channelDetails.text)
    
>       assert channelDetailsR["all_members"] == [
                                                {
                                                    'u_id': userR["auth_user_id"],
                                                    'email': 'test@hotmail.com',
                                                    'name_first': 'nameFirst',
                                                    'name_last': 'nameLast',
                                                    'handle_str': 'namefirstnamelast',
    
                                                },
    
                                                {
                                                    'u_id': user2R["auth_user_id"],
                                                    'email': 'test2@hotmail.com',
                                                    'name_first': 'nameFirst',
                                                    'name_last': 'nameLast',
                                                    'handle_str': 'namefirstnamelast0',
    
                                                },
    
                                                {
                                                    'u_id': user3R["auth_user_id"],
                                                    'email': 'test3@hotmail.com',
                                                    'name_first': 'nameFirst',
                                                    'name_last': 'nameLast',
                                                    'handle_str': 'namefirstnamelast1',
    
                                                }
                                            ]
E       AssertionError: assert [{'email': 't...meLast', ...}] == [{'email': 't...meLast', ...}]
E         At index 0 diff: {'email': 'test3@hotmail.com', 'handle_str': 'namefirstnamelast1', 'name_first': 'nameFirst', 'name_last': 'nameLast', 'profile_img_url': '', 'u_id': 69} != {'u_id': 67, 'email': 'test@hotmail.com', 'name_first': 'nameFirst', 'name_last': 'nameLast', 'handle_str': 'namefirstnamelast'}
E         Use -v to get the full diff

http_tests/channel_http_test.py:320: AssertionError
_________________________ testaddowner_invalid_tokenn __________________________

    def testaddowner_invalid_tokenn():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Add Owner ------
        funcURL = "channel/addowner/v1"
        temp = jwt.encode({"sessionId": 243343}, database.secretSauce, algorithm = "HS256")
        inputData = {
            "token": temp,
            "channel_id": channelR["channel_id"],
            "u_id": user2R["token"],
        }
        addOwner = requests.post(config.url + funcURL, json=inputData)
>       addOwnerR = json.loads(addOwner.text)

http_tests/channel_http_test.py:397: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testaddowner_invalid_uID ___________________________

    def testaddowner_invalid_uID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Add Owner ------
        funcURL = "channel/addowner/v1"
        temp = jwt.encode({"sessionId": 243343}, database.secretSauce, algorithm = "HS256")
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "u_id": temp,
        }
        addOwner = requests.post(config.url + funcURL, json=inputData)
>       addOwnerR = json.loads(addOwner.text)

http_tests/channel_http_test.py:446: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ testaddowner_invalid_channelID ________________________

    def testaddowner_invalid_channelID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(channel.text)
    
        # Add Owner ------
        funcURL = "channel/addowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_channel",
            "u_id": user2R["auth_user_id"],
        }
        addOwner = requests.post(config.url + funcURL, json=inputData)
>       addOwnerR = json.loads(addOwner.text)

http_tests/channel_http_test.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________ testaddowner_already_owner __________________________

    def testaddowner_already_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(channel.text)
    
        # Add Owner ------
        funcURL = "channel/addowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_channel",
            "u_id": userR["auth_user_id"],
        }
        addOwner = requests.post(config.url + funcURL, json=inputData)
>       addOwnerR = json.loads(addOwner.text)

http_tests/channel_http_test.py:542: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ testaddowner_unauthorised_token ________________________

    def testaddowner_unauthorised_token():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Register Third Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join Person 2 -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(join.text)
    
        # Channel Join Person 3 -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user3R["token"],
            "channel_id": channelR["channel_id"],
        }
        join2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(join2.text)
    
        # Add Owner ------
        funcURL = "channel/addowner/v1"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
            "u_id": user3R["auth_user_id"],
        }
        addOwner = requests.post(config.url + funcURL, json=inputData)
>       addOwnerR = json.loads(addOwner.text)

http_tests/channel_http_test.py:619: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>You don\'t have permission to add an owner</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ testaddowner_not_in_channel __________________________

    def testaddowner_not_in_channel():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Register Third Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join Person 2 -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(join.text)
    
        # Add Owner ------
        funcURL = "channel/addowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "u_id": user3R["auth_user_id"],
        }
        addOwner = requests.post(config.url + funcURL, json=inputData)
        addOwnerR = json.loads(addOwner.text)
>       assert addOwnerR["code"] == 403
E       KeyError: 'code'

http_tests/channel_http_test.py:688: KeyError
___________________________ testaddowner_valid_case ____________________________

    def testaddowner_valid_case():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join Person 2 -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        join = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(join.text)
    
        # Add Owner ------
        funcURL = "channel/addowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "u_id": user2R["auth_user_id"],
        }
        addOwner = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(addOwner.text)
    
        # Channel Details
        funcURL = "channel/details/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
        }
        qData = urllib.parse.urlencode(inputData)
        channelDetails = requests.get(config.url + funcURL + "?" + qData)
        channelDetailsR = json.loads(channelDetails.text)
    
>       assert channelDetailsR["owner_members"] == [
                                                {
                                                    'u_id': userR["auth_user_id"],
                                                    'email': 'test@hotmail.com',
                                                    'name_first': 'nameFirst',
                                                    'name_last': 'nameLast',
                                                    'handle_str': 'namefirstnamelast',
    
                                                },
    
                                                {
                                                    'u_id': user2R["auth_user_id"],
                                                    'email': 'test2@hotmail.com',
                                                    'name_first': 'nameFirst',
                                                    'name_last': 'nameLast',
                                                    'handle_str': 'namefirstnamelast0',
    
                                                }
                                                ]
E       AssertionError: assert [{'email': 't...meLast', ...}] == [{'email': 't...meLast', ...}]
E         At index 0 diff: {'email': 'test2@hotmail.com', 'handle_str': 'namefirstnamelast0', 'name_first': 'nameFirst', 'name_last': 'nameLast', 'profile_img_url': '', 'u_id': 92} != {'u_id': 91, 'email': 'test@hotmail.com', 'name_first': 'nameFirst', 'name_last': 'nameLast', 'handle_str': 'namefirstnamelast'}
E         Use -v to get the full diff

http_tests/channel_http_test.py:756: AssertionError
__________________ test_http_channel_removeowner_invalid_user __________________

    def test_http_channel_removeowner_invalid_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Adding Owner--------------------
        funcURL = "channel/addowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "u_id": user2R["auth_user_id"],
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Removing Owner--------------------
        funcURL = "channel/removeowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "u_id": "invalid_user",
        }
        removeOwner = requests.post(config.url + funcURL, json=inputData)
>       removeOwnerR = json.loads(removeOwner.text)

http_tests/channel_http_test.py:891: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________ test_http_channel_removeowner_invalid_channel _________________

    def test_http_channel_removeowner_invalid_channel():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Adding Owner--------------------
        funcURL = "channel/addowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "u_id": user2R["auth_user_id"],
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Removing Owner--------------------
        funcURL = "channel/removeowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_channel",
            "u_id": user2R["auth_user_id"],
        }
        removeOwner = requests.post(config.url + funcURL, json=inputData)
>       removeOwnerR = json.loads(removeOwner.text)

http_tests/channel_http_test.py:946: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________ test_http_channel_removeowner_only_owner ___________________

    def test_http_channel_removeowner_only_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Removing Owner--------------------
        funcURL = "channel/removeowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_channel",
            "u_id": userR["auth_user_id"],
        }
        removeOwner = requests.post(config.url + funcURL, json=inputData)
>       removeOwnerR = json.loads(removeOwner.text)

http_tests/channel_http_test.py:980: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________ test_http_channel_removeowner_not_owner ____________________

    def test_http_channel_removeowner_not_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Removing Owner--------------------
        funcURL = "channel/removeowner/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_channel",
            "u_id": user2R["auth_user_id"],
        }
        removeOwner = requests.post(config.url + funcURL, json=inputData)
>       removeOwnerR = json.loads(removeOwner.text)

http_tests/channel_http_test.py:1025: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________ test_http_channel_removeowner_invalid_token __________________

    def test_http_channel_removeowner_invalid_token():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Removing Owner--------------------
        funcURL = "channel/removeowner/v1"
        inputData = {
            "token": user2R["token"],
            "channel_id": "invalid_channel",
            "u_id": userR["auth_user_id"],
        }
        removeOwner = requests.post(config.url + funcURL, json=inputData)
>       removeOwnerR = json.loads(removeOwner.text)

http_tests/channel_http_test.py:1070: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________ test_http_channel_leave_channel_valid _____________________

    def test_http_channel_leave_channel_valid():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Leaving Channel--------------
        funcURL = "channel/leave/v1"
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_channel_id"
        }
        channelLeave = requests.post(config.url + funcURL, json=inputData)
>       channelLeaveR = json.loads(channelLeave.text)

http_tests/channel_http_test.py:1155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_channel_leave_user_valid ______________________

    def test_http_channel_leave_user_valid():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
        # Leaving Channel--------------
        funcURL = "channel/leave/v1"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"]
        }
        channelLeave = requests.post(config.url + funcURL, json=inputData)
>       channelLeaveR = json.loads(channelLeave.text)

http_tests/channel_http_test.py:1201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Not a member of testChannel</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_channel_messages_working ______________________

    def test_http_channel_messages_working():
    
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
    
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Hello World",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Channel Message Info -------
        funcURL = "channel/messages/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        channelMessages = requests.get(config.url + funcURL + "?" + qData)
        channelMessagesR = json.loads(channelMessages.text)
    
        for msg in channelMessagesR["messages"]:
>           assert msg["message_id"] == 1
E           assert 121 == 1

http_tests/channel_http_test.py:1255: AssertionError
__________________ test_http_channel_messages_invalid_channel __________________

    def test_http_channel_messages_invalid_channel():
    
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Message Info -------
        funcURL = "channel/messages/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": 50,
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        channelMessages = requests.get(config.url + funcURL + "?" + qData)
>       channelMessagesR = json.loads(channelMessages.text)

http_tests/channel_http_test.py:1283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>50 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________ test_http_channel_messages_startgreater ____________________

    def test_http_channel_messages_startgreater():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
        # Checking Messages-----------------
        funcURL = "channel/messages/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "start": 1,
        }
        qData = urllib.parse.urlencode(inputData)
        dmMessages = requests.get(config.url + funcURL + "?" + qData)
>       dmMessagesR = json.loads(dmMessages.text)

http_tests/channel_http_test.py:1321: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Incorrect pagination start (1 &gt; 0)</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________ test_http_channel_messages_not_authorised ___________________

    def test_http_channel_messages_not_authorised():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
    
        # Checking Messages-----------------
        funcURL = "channel/messages/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        dmMessages = requests.get(config.url + funcURL + "?" + qData)
>       dmMessagesR = json.loads(dmMessages.text)

http_tests/channel_http_test.py:1371: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Only members can view messages</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_channels_create_working _______________________

    def test_http_channels_create_working():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
    
>       assert channelR["channel_id"] == 0
E       assert 131 == 0

http_tests/channels_http_test.py:39: AssertionError
______________________ test_http_channels_create_multiple ______________________

    def test_http_channels_create_multiple():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "Channel2",
            "is_public": True,
        }
        channel2 = requests.post(config.url + funcURL, json=inputData)
        channel2R = json.loads(channel2.text)
        # ----------------------------
    
>       assert channelR["channel_id"] == 0
E       assert 133 == 0

http_tests/channels_http_test.py:79: AssertionError
___________________ test_http_channels_create_invalid_token ____________________

    def test_http_channels_create_invalid_token():
    
        requests.delete(config.url + "clear/v1")
        temp = jwt.encode({"sessionId": 7}, database.secretSauce, algorithm = "HS256")
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": temp,
            "name": "TestChannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
>       channelR = json.loads(channel.text)

http_tests/channels_http_test.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________ test_http_channels_create_longer_than_twenty_char _______________

    def test_http_channels_create_longer_than_twenty_char():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "a" * 21,
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
>       channelR = json.loads(channel.text)

http_tests/channels_http_test.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Channel name too long</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ test_http_channels_list_working ________________________

    def test_http_channels_list_working():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": user2R["token"],
            "name": "testChannel2",
            "is_public": True,
        }
        channel2 = requests.post(config.url + funcURL, json=inputData)
        channel2R = json.loads(channel2.text)
        # ----------------------------
    
        # Channel Join -------
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        # Listing Channel--------------
        funcURL = "channels/list/v2"
        inputData = {
            "token": user2R["token"],
        }
        qData = urllib.parse.urlencode(inputData)
        channelList = requests.get(config.url + funcURL + "?" + qData)
        channelListR = json.loads(channelList.text)
    
>       assert channelListR == {'channels': [{'channel_id': channelR["channel_id"], 'name': 'testChannel'}, {'channel_id': channel2R["channel_id"], 'name': 'testChannel2'}]}
E       AssertionError: assert {'channels': ...estChannel'}]} == {'channels': ...stChannel2'}]}
E         Differing items:
E         {'channels': [{'channel_id': 140, 'name': 'testChannel2'}, {'channel_id': 139, 'name': 'testChannel'}]} != {'channels': [{'channel_id': 139, 'name': 'testChannel'}, {'channel_id': 140, 'name': 'testChannel2'}]}
E         Use -v to get the full diff

http_tests/channels_http_test.py:197: AssertionError
_____________________ test_http_channels_list_invalid_user _____________________

    def test_http_channels_list_invalid_user():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        invalid_token = jwt.encode({"sessionId": 999}, database.secretSauce, algorithm = "HS256")
        # Listing Channel--------------
        funcURL = "channels/list/v2"
        inputData = {
            "token": invalid_token,
        }
        qData = urllib.parse.urlencode(inputData)
        channelList = requests.get(config.url + funcURL + "?" + qData)
>       channelListR = json.loads(channelList.text)

http_tests/channels_http_test.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________ test_http_channels_listall_invalid_user ____________________

    def test_http_channels_listall_invalid_user():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        invalid_token = jwt.encode({"sessionId": 999}, database.secretSauce, algorithm = "HS256")
        # Listing Channel--------------
        funcURL = "channels/listall/v2"
        inputData = {
            "token": invalid_token,
        }
        qData = urllib.parse.urlencode(inputData)
        channelList = requests.get(config.url + funcURL + "?" + qData)
>       channelListR = json.loads(channelList.text)

http_tests/channels_http_test.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ test_http_dm_create_working __________________________

    def test_http_dm_create_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ test_http_dm_create_invalid_user _______________________

    def test_http_dm_create_invalid_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        userList.append(7)
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>7 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_dm_create_invalid_token _______________________

    def test_http_dm_create_invalid_token():
        requests.delete(config.url + "clear/v1")
        temp = jwt.encode({"sessionId": 7}, database.secretSauce, algorithm = "HS256")
    
        funcURL = "dm/create/v1"
        inputData = {
            "token": temp,
            "u_ids": [],
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ test_http_dm_invite_working __________________________

    def test_http_dm_invite_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Inviting User 3 to DM-----------------
        funcURL = "dm/invite/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": 0,
            "u_id": 2
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # List the DMS that user 3 is in
        funcURL = "dm/list/v1"
        inputData = {
                "token": user3R["token"],
        }
        qData = urllib.parse.urlencode(inputData)
        dmList = requests.get(config.url + funcURL + "?" + qData)
        dmListR = json.loads(dmList.text)
    
>       assert dmListR == {"dms": [{"dm_id": 0, "dm_name": "namefirstnamelast,namefirstnamelast0"}]}
E       AssertionError: assert {'dms': []} == {'dms': [{'dm...tnamelast0'}]}
E         Differing items:
E         {'dms': []} != {'dms': [{'dm_id': 0, 'dm_name': 'namefirstnamelast,namefirstnamelast0'}]}
E         Use -v to get the full diff

http_tests/dm_http_test.py:173: AssertionError
_______________________ test_http_dm_invite_invalid_dmid _______________________

    def test_http_dm_invite_invalid_dmid():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # ----------------------------
    
        # Invite-----------------
        funcURL = "dm/invite/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": 0,
            "u_id": 1
        }
        dmInv = requests.post(config.url + funcURL, json=inputData)
>       dmInvR = json.loads(dmInv.text)

http_tests/dm_http_test.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>0 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ test_http_dm_invite_invalid_uid ________________________

    def test_http_dm_invite_invalid_uid():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Invite-----------------
        funcURL = "dm/invite/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": 0,
            "u_id": 8
        }
        dmInv = requests.post(config.url + funcURL, json=inputData)
>       dmInvR = json.loads(dmInv.text)

http_tests/dm_http_test.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>0 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ test_http_dm_inviter_not_in_dm ________________________

    def test_http_dm_inviter_not_in_dm():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------
    
         # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test4@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        user4R = json.loads(user3.text)
        # ----------------------------
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Invite-----------------
        funcURL = "dm/invite/v1"
        inputData = {
            "token": user3R["token"],
            "dm_id": 0,
            "u_id": user4R["auth_user_id"]
        }
        dmInv = requests.post(config.url + funcURL, json=inputData)
>       dmInvR = json.loads(dmInv.text)

http_tests/dm_http_test.py:327: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>0 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________ test_http_dm_list_working ___________________________

    def test_http_dm_list_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user3R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Creating DM LIST---------------
        funcURL = "dm/list/v1"
        inputData = {
                "token": userR["token"],
        }
        qData = urllib.parse.urlencode(inputData)
        dmList = requests.get(config.url + funcURL + "?" + qData)
        dmListR = json.loads(dmList.text)
>       assert dmListR == {"dms": [{"dm_id": 0, "dm_name": "namefirstnamelast,namefirstnamelast0"},
         {"dm_id": 1, "dm_name": "namefirstnamelast,namefirstnamelast1"}]}
E       AssertionError: assert {'dms': [{'dm...tnamelast1'}]} == {'dms': [{'dm...tnamelast1'}]}
E         Differing items:
E         {'dms': [{'dm_id': 168, 'name': 'namefirstnamelast, namefirstnamelast0'}, {'dm_id': 169, 'name': 'namefirstnamelast, namefirstnamelast1'}]} != {'dms': [{'dm_id': 0, 'dm_name': 'namefirstnamelast,namefirstnamelast0'}, {'dm_id': 1, 'dm_name': 'namefirstnamelast,namefirstnamelast1'}]}
E         Use -v to get the full diff

http_tests/dm_http_test.py:399: AssertionError
_______________________ test_http_dm_list_invalid_token ________________________

    def test_http_dm_list_invalid_token():
        requests.delete(config.url + "clear/v1")
        temp = jwt.encode({"sessionId": 7}, database.secretSauce, algorithm = "HS256")
    
        funcURL = "dm/list/v1"
        inputData = {
                "token": temp,
        }
        qData = urllib.parse.urlencode(inputData)
        dmList = requests.get(config.url + funcURL + "?" + qData)
>       dmListR = json.loads(dmList.text)

http_tests/dm_http_test.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________ test_http_dm_leave_working __________________________

    def test_http_dm_leave_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ test_http_dm_leave_invalid_dm _________________________

    def test_http_dm_leave_invalid_dm():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Leaving DM-----------------
        funcURL = "dm/leave/v1"
        inputData = {
            "token": user2R["token"],
            "dm_id": "invalid_dm_id",
        }
        dmLeft = requests.post(config.url + funcURL, json=inputData)
>       dmLeftR = json.loads(dmLeft.text)

http_tests/dm_http_test.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________ test_http_dm_leave_unauthorized_user _____________________

    def test_http_dm_leave_unauthorized_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
         # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:568: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ test_http_dm_leave_invalid_token _______________________

    def test_http_dm_leave_invalid_token():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:617: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ test_http_dm_remove_working __________________________

    def test_http_dm_remove_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:668: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ test_http_dm_remove_invalid_id ________________________

    def test_http_dm_remove_invalid_id():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Removing DM-----------------
        funcURL = "dm/remove/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": "invalid_dm_id",
        }
        dmRemoved = requests.delete(config.url + funcURL, json=inputData)
>       dmRemovedR = json.loads(dmRemoved.text)

http_tests/dm_http_test.py:741: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ test_http_dm_remove_not_owner _________________________

    def test_http_dm_remove_not_owner():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:781: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_dm_remove_invalid_token _______________________

    def test_http_dm_remove_invalid_token():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:830: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ test_http_dm_message_working _________________________

    def test_http_dm_message_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:880: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_dm_message_invalid_user _______________________

    def test_http_dm_message_invalid_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:931: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ test_http_dm_message_invalid_dm ________________________

    def test_http_dm_message_invalid_dm():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
        # Checking Messages-----------------
        funcURL = "dm/messages/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": 999,
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        dmMessages = requests.get(config.url + funcURL + "?" + qData)
>       dmMessagesR = json.loads(dmMessages.text)

http_tests/dm_http_test.py:992: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>999 is not a valid ID</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________ test_http_dm_message_unauthorised_user ____________________

    def test_http_dm_message_unauthorised_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:1043: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________ test_http_dm_message_startgreater _______________________

    def test_http_dm_message_startgreater():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:1094: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________ test_http_dm_message_endnegativeone ______________________

    def test_http_dm_message_endnegativeone():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/dm_http_test.py:1145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________ test_http_dm_details_dm_does_not_exist ____________________

    def test_http_dm_details_dm_does_not_exist():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       _ = json.loads(dm.text)

http_tests/dm_http_test.py:1198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________ test_http_dm_details_user_not_member_of_dm __________________

    def test_http_dm_details_user_not_member_of_dm():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
        # ----------------------------------
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        inputData = {
            "token": userR["token"],
            "u_ids": [user2R["auth_user_id"]],
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
        # ---------------------------
        # checking details -----------
        funcURL = "dm/details/v1"
        inputData = {
            "token": user3R['token'],
            "dm_id": dmR["dm_id"]
        }
        qData = urllib.parse.urlencode(inputData)
        dmDetails = requests.get(config.url + funcURL + "?" + qData)
>       dmDetailsR = json.loads(dmDetails.text)

http_tests/dm_http_test.py:1266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Only members can view details about this channel</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
__________________________ test_http_dm_details_valid __________________________

    def test_http_dm_details_valid():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
         # Creating DM-----------------
        funcURL = "dm/create/v1"
        inputData = {
            "token": userR["token"],
            "u_ids": [user2R["auth_user_id"]],
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
        # ---------------------------
        # checking details -----------
        funcURL = "dm/details/v1"
        inputData = {
            "token": userR['token'],
            "dm_id": dmR["dm_id"]
        }
        qData = urllib.parse.urlencode(inputData)
        dmDetails = requests.get(config.url + funcURL + "?" + qData)
        dmDetailsR = json.loads(dmDetails.text)
>       assert dmDetailsR == {
            'name': 'namelastname,namelastname0',
            'members': [
                {
                    'u_id': userR["auth_user_id"],
                    'email': 'email@gmail.com',
                    'name_first': 'Name',
                    'name_last': 'Lastname',
                    'handle_str': 'namelastname',
    
                },
                {
                    'u_id': user2R["auth_user_id"],
                    'email': 'email2@gmail.com',
                    'name_first': 'Name',
                    'name_last': 'Lastname',
                    'handle_str': 'namelastname0',
                }
            ]
        }
E       AssertionError: assert {'members': [...amelastname0'} == {'members': [...amelastname0'}
E         Differing items:
E         {'members': [{'email': 'email2@gmail.com', 'handle_str': 'namelastname0', 'name_first': 'Name', 'name_last': 'Lastname', ...}, {'email': 'email@gmail.com', 'handle_str': 'namelastname', 'name_first': 'Name', 'name_last': 'Lastname', ...}]} != {'members': [{'email': 'email@gmail.com', 'handle_str': 'namelastname', 'name_first': 'Name', 'name_last': 'Lastname', ...}, {'email': 'email2@gmail.com', 'handle_str': 'namelastname0', 'name_first': 'Name', 'name_last': 'Lastname', ...}]}
E         {'name': 'namelastname, namelastname0'} != {'name': 'namelastname,namelastname...
E         
E         ...Full output truncated (2 lines hidden), use '-vv' to show

http_tests/dm_http_test.py:1313: AssertionError
__________________________________ test_echo ___________________________________

    def test_echo():
        '''
        A simple test to check echo
        '''
        resp = requests.get(config.url + 'echo', params={'data': 'hello'})
>       assert json.loads(resp.text) == {'data': 'hello'}

http_tests/echo_http_test.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>404 Not Found</title>\n<h1>Not Found</h1>\n<p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________________ testsend_empty_message ____________________________

    def testsend_empty_message():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message send
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": '',
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
>       assert messageSendR["code"] == 400
E       KeyError: 'code'

http_tests/message_http_test.py:52: KeyError
__________________________ testsend_invalid_long_msg ___________________________

    def testsend_invalid_long_msg():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message send
        funcURL = "message/send/v2"
        temp = 'x' * 2000
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": temp,
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
>       messageSendR = json.loads(messageSend.text)

http_tests/message_http_test.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Messages should be between 0 and 1000 characters long</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________________ testsend_invalid_token ____________________________

    def testsend_invalid_token():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message send
        funcURL = "message/send/v2"
        invalid_token = jwt.encode({"sessionId": 2954}, database.secretSauce, algorithm = "HS256")
    
        inputData = {
            "token": invalid_token,
            "channel_id": channelR["channel_id"],
            "message": "This is a message from Thomas Chen",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
>       messageSendR = json.loads(messageSend.text)

http_tests/message_http_test.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testsend_invalid_channel ___________________________

    def testsend_invalid_channel():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Message send
        funcURL = "message/send/v2"
    
        inputData = {
            "token": userR["token"],
            "channel_id": "invalid_id",
            "message": "This is a message from Thomas Chen",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
>       messageSendR = json.loads(messageSend.text)

http_tests/message_http_test.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ testsend_sent_not_in_channel _________________________

    def testsend_sent_not_in_channel():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message send
        funcURL = "message/send/v2"
    
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
            "message": "This is a message from Thomas Chen",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
>       messageSendR = json.loads(messageSend.text)

http_tests/message_http_test.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>namefirstnamelast0 not a member of testchannel</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________________ testsend_valid_case ______________________________

    def testsend_valid_case():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
    
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "lol",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Channel Message Info -------
        funcURL = "channel/messages/v2"
    
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        channelMessages = requests.get(config.url + funcURL + "?" + qData)
        channelMessagesR = json.loads(channelMessages.text)
    
        for msg in channelMessagesR["messages"]:
>           assert msg["message_id"] == 1
E           assert 238 == 1

http_tests/message_http_test.py:264: AssertionError
________________________________ testedit_empty ________________________________

    def testedit_empty():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas Chen and Jonathan Qiu",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Edit
        funcURL = "message/edit/v2"
    
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
            "message": '',
        }
        messageEdit = requests.put(config.url + funcURL, json=inputData)
        messageEditR = json.loads(messageEdit.text)
>       assert messageEditR["code"] == 400
E       KeyError: 'code'

http_tests/message_http_test.py:316: KeyError
__________________________ testedit_invalid_long_msg ___________________________

    def testedit_invalid_long_msg():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas Chen and Jonathan Qiu",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Edit
        funcURL = "message/edit/v2"
        temp = 'x' * 9999
    
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
            "message": temp,
        }
        messageEdit = requests.put(config.url + funcURL, json=inputData)
>       messageEditR = json.loads(messageEdit.text)

http_tests/message_http_test.py:363: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Messages should be between 0 and 1000 characters long</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________________ testedit_invalid_token ____________________________

    def testedit_invalid_token():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas Chen and Jonathan Qiu",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Edit
        funcURL = "message/edit/v2"
        invalid_token = jwt.encode({"sessionId": 2}, database.secretSauce, algorithm = "HS256")
    
        inputData = {
            "token": invalid_token,
            "message_id": messageSendR["message_id"],
            "message": "Change this to Jonathan Qiu",
        }
        messageEdit = requests.put(config.url + funcURL, json=inputData)
>       messageEditR = json.loads(messageEdit.text)

http_tests/message_http_test.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________________ testedit_invalid_mID _____________________________

    def testedit_invalid_mID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send --------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas Chen and Jonathan Qiu",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Message Edit ---------
        funcURL = "message/edit/v2"
    
        inputData = {
            "token": userR["token"],
            "message_id": "invalid_mID",
            "message": "Change this to Jonathan Qiu",
        }
        messageEdit = requests.put(config.url + funcURL, json=inputData)
>       messageEditR = json.loads(messageEdit.text)

http_tests/message_http_test.py:459: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testedit_not_authorised ____________________________

    def testedit_not_authorised():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas Chen and Jonathan Qiu",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Edit
        funcURL = "message/edit/v2"
    
        inputData = {
            "token": user2R["token"],
            "message_id": messageSendR["message_id"],
            "message": "Change this to Jonathan Qiu",
        }
    
        messageEdit = requests.put(config.url + funcURL, json=inputData)
>       messageEditR = json.loads(messageEdit.text)

http_tests/message_http_test.py:518: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>namefirstnamelast0 cannot edit this message</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________________ testedit_valid_case ______________________________

    def testedit_valid_case():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Edit ----------
        funcURL = "message/edit/v2"
    
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
            "message": "Jonathan",
        }
        messageEdit = requests.put(config.url + funcURL, json=inputData)
        _ = json.loads(messageEdit.text)
    
        # Channel Message Info -------
        funcURL = "channel/messages/v2"
    
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        channelMessages = requests.get(config.url + funcURL + "?" + qData)
        channelMessagesR = json.loads(channelMessages.text)
    
        for msg in channelMessagesR["messages"]:
>           assert msg["message_id"] == 1
E           assert 257 == 1

http_tests/message_http_test.py:580: AssertionError
_________________________ testedit_comprehensive_valid _________________________

    def testedit_comprehensive_valid():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join -----
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Edit ----------
        funcURL = "message/edit/v2"
    
        inputData = {
            "token": userR["token"],
            "message_id": messageSendR["message_id"],
            "message": "Jonathan",
        }
        messageEdit = requests.put(config.url + funcURL, json=inputData)
        _ = json.loads(messageEdit.text)
    
        # Channel Message Info -------
        funcURL = "channel/messages/v2"
    
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        channelMessages = requests.get(config.url + funcURL + "?" + qData)
        channelMessagesR = json.loads(channelMessages.text)
    
        for msg in channelMessagesR["messages"]:
>           assert msg["message_id"] == 1
E           assert 261 == 1

http_tests/message_http_test.py:663: AssertionError
_________________________ testremove_invalid_token_id __________________________

    def testremove_invalid_token_id():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send ------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas Chen and Jonathan Qiu",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Remove ----
        funcURL = "message/remove/v1"
        invalid_token = jwt.encode({"sessionId": 2}, database.secretSauce, algorithm = "HS256")
    
        inputData = {
            "token": invalid_token,
            "message_id": messageSendR["message_id"],
        }
        messageRemove = requests.delete(config.url + funcURL, json=inputData)
>       messageRemoveR = json.loads(messageRemove.text)

http_tests/message_http_test.py:714: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________________ testremove_invalid_mID ____________________________

    def testremove_invalid_mID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send ------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas Chen and Jonathan Qiu",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Message Remove ----
        funcURL = "message/remove/v1"
    
        inputData = {
            "token": userR["token"],
            "message_id": "invalid_id",
        }
        messageRemove = requests.delete(config.url + funcURL, json=inputData)
>       messageRemoveR = json.loads(messageRemove.text)

http_tests/message_http_test.py:761: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________________ testremove_empty _______________________________

    def testremove_empty():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Message Remove ----
        funcURL = "message/remove/v1"
    
        inputData = {
            "token": userR["token"],
            "message_id": "m_id",
        }
        messageRemove = requests.delete(config.url + funcURL, json=inputData)
>       messageRemoveR = json.loads(messageRemove.text)

http_tests/message_http_test.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testremove_unauthorised ____________________________

    def testremove_unauthorised():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Channel Join -----
        funcURL = "channel/join/v2"
        inputData = {
            "token": user2R["token"],
            "channel_id": channelR["channel_id"],
        }
        _ = requests.post(config.url + funcURL, json=inputData)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        # Message Remove ----
        funcURL = "message/remove/v1"
    
        inputData = {
            "token": user2R["token"],
            "message_id": messageSendR["message_id"],
        }
        messageRemove = requests.delete(config.url + funcURL, json=inputData)
>       messageRemoveR = json.loads(messageRemove.text)

http_tests/message_http_test.py:852: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>You do not have permission to remove messages</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_______________________ testsenddm_invalid_empty_message _______________________

    def testsenddm_invalid_empty_message():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Message Send DM -------
        funcURL = "message/senddm/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": dmR["dm_id"],
            "message": "",
        }
        messageSendDM = requests.post(config.url + funcURL, json=inputData)
        messageSendDMR = json.loads(messageSendDM.text)
>       assert messageSendDMR["code"] == 400
E       KeyError: 'code'

http_tests/message_http_test.py:1047: KeyError
_________________________ testsenddm_invalid_long_msg __________________________

    def testsenddm_invalid_long_msg():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Message Send DM -------
        funcURL = "message/senddm/v1"
        temp = 'x' * 2000
        inputData = {
            "token": userR["token"],
            "dm_id": dmR["dm_id"],
            "message": temp,
        }
        messageSendDM = requests.post(config.url + funcURL, json=inputData)
>       messageSendDMR = json.loads(messageSendDM.text)

http_tests/message_http_test.py:1096: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>Messages should be between 0 and 1000 characters long</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ testsenddm_invalid_token_ID __________________________

    def testsenddm_invalid_token_ID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Message Send DM -------
        funcURL = "message/senddm/v1"
        invalid_token = jwt.encode({"sessionId": "notInt"}, database.secretSauce, algorithm = "HS256")
        inputData = {
            "token": invalid_token,
            "dm_id": dmR["dm_id"],
            "message": "Jonathan Qiu is such a nice guy",
        }
        messageSendDM = requests.post(config.url + funcURL, json=inputData)
>       messageSendDMR = json.loads(messageSendDM.text)

http_tests/message_http_test.py:1145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
___________________________ testsenddm_invalid_dmID ____________________________

    def testsenddm_invalid_dmID():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(dm.text)
    
        # Message Send DM -------
        funcURL = "message/senddm/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": "invalid_dmID",
            "message": "Jonathan Qiu is such a nice guy",
        }
        messageSendDM = requests.post(config.url + funcURL, json=inputData)
>       messageSendDMR = json.loads(messageSendDM.text)

http_tests/message_http_test.py:1193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>500 Internal Server Error</title>\n<h1>Internal Serve...nd was unable to complete your request. Either the server is overloaded or there is an error in the application.</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_________________________ testsenddm_unauthorised_user _________________________

    def testsenddm_unauthorised_user():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Register Third Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test3@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user3 = requests.post(config.url + funcURL, json=inputData)
        user3R = json.loads(user3.text)
    
        # Message Send DM -------
        funcURL = "message/senddm/v1"
        inputData = {
            "token": user3R["token"],
            "dm_id": dmR["dm_id"],
            "message": "Jonathan Qiu is such a nice guy",
        }
        messageSendDM = requests.post(config.url + funcURL, json=inputData)
>       messageSendDMR = json.loads(messageSendDM.text)

http_tests/message_http_test.py:1253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>namefirstnamelast1 not a member of namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
____________________________ testsenddm_valid_case _____________________________

    def testsenddm_valid_case():
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register Second Person --------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # DM Create -------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
    
        # Message Send DM -------
        funcURL = "message/senddm/v1"
        inputData = {
            "token": user2R["token"],
            "dm_id": dmR["dm_id"],
            "message": "Jonathan Qiu is such a nice guy",
        }
        messageSendDM = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSendDM.text)
    
        # DM Message Info -------
        funcURL = "dm/messages/v1"
    
        inputData = {
            "token": user2R["token"],
            "dm_id": dmR["dm_id"],
            "start": 0,
        }
        qData = urllib.parse.urlencode(inputData)
        dmMessages = requests.get(config.url + funcURL + "?" + qData)
        dmMessagesR = json.loads(dmMessages.text)
    
        for msg in dmMessagesR["messages"]:
>           assert msg["message_id"] == 1
E           assert 300 == 1

http_tests/message_http_test.py:1316: AssertionError
___________ test_http_message_share_not_member_of_channel_sharing_to ___________

    def test_http_message_share_not_member_of_channel_sharing_to():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(user2.text)
        # ----------------------------
        # Creating Channel--------------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testChannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
        # ----------------------------
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Thomas",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
    
        #checking message_share
        funcURL = "message/share/v1"
        invalidToken = jwt.encode({"sessionId": 8}, database.secretSauce, algorithm="HS256")
        inputData ={
            'token': invalidToken,
            'og_message_id': messageSendR["message_id"],
            'message': "",
            'channel_id': channelR['channel_id'],
            'dm_id': -1,
        }
        messageShare = requests.post(config.url + funcURL, json=inputData)
>       messageShareR = json.loads(messageShare.text)

http_tests/message_http_test.py:1408: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________ test_http_message_share_not_member_of_dm_sharing_to ______________

    def test_http_message_share_not_member_of_dm_sharing_to():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email@gmai.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
        # ----------------------------
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "email2@gmail.com",
            "password": "password1",
            "name_first": "Name",
            "name_last": "Lastname",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
        # ----------------------------
         # Creating DM-----------------
        funcURL = "dm/create/v1"
        inputData = {
            "token": userR["token"],
            "u_ids": [user2R["auth_user_id"]],
        }
        dm = requests.post(config.url + funcURL, json=inputData)
        dmR = json.loads(dm.text)
        # ---------------------------
        # Message Send -------
        funcURL = "message/senddm/v1"
        inputData = {
            "token": userR["token"],
            "dm_id": dmR["dm_id"],
            "message": "Hi",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        messageSendR = json.loads(messageSend.text)
    
        invalidToken = jwt.encode({"sessionId": 8}, database.secretSauce, algorithm="HS256")
        #checking message_share
        funcURL = "message/share/v1"
        inputData ={
            'token': invalidToken,
            'og_message_id': messageSendR["message_id"],
            'message': "",
            'channel_id': -1,
            'dm_id': dmR['dm_id'],
        }
        messageShare = requests.post(config.url + funcURL, json=inputData)
>       messageShareR = json.loads(messageShare.text)

http_tests/message_http_test.py:1467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
______________________________ test_http_clear_dm ______________________________

    def test_http_clear_dm():
    
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user2 = requests.post(config.url + funcURL, json=inputData)
        user2R = json.loads(user2.text)
    
        # Creating DM-----------------
        funcURL = "dm/create/v1"
        userList = []
        userList.append(userR["auth_user_id"])
        userList.append(user2R["auth_user_id"])
        inputData = {
            "token": userR["token"],
            "u_ids": userList,
        }
        dm = requests.post(config.url + funcURL, json=inputData)
>       dmR = json.loads(dm.text)

http_tests/other_http_test.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>400 Bad Request</title>\n<h1>Bad Request</h1>\n<p>namefirstnamelast is already a member of namefirstnamelast, namefirstnamelast, namefirstnamelast0</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
_____________________________ test_search_working ______________________________

    def test_search_working():
    
        requests.delete(config.url + "clear/v1")
    
        # Register --------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        user = requests.post(config.url + funcURL, json=inputData)
        userR = json.loads(user.text)
    
        # Channel Create -------
        funcURL = "channels/create/v2"
        inputData = {
            "token": userR["token"],
            "name": "testchannel",
            "is_public": True,
        }
        channel = requests.post(config.url + funcURL, json=inputData)
        channelR = json.loads(channel.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Hello Guys",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Hello World",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Message Send -------
        funcURL = "message/send/v2"
        inputData = {
            "token": userR["token"],
            "channel_id": channelR["channel_id"],
            "message": "Should not be seen in search",
        }
        messageSend = requests.post(config.url + funcURL, json=inputData)
        _ = json.loads(messageSend.text)
    
        # Search
        funcURL = "search/v2"
        inputData = {
            "token": userR["token"],
            "query_str": "Hello",
        }
        qData = urllib.parse.urlencode(inputData)
        searchx = requests.get(config.url + funcURL + "?" + qData)
        searchxR = json.loads(searchx.text)
        search_list = searchxR["messages"]
    
>       assert search_list[0].get("message_id") == 1
E       AssertionError: assert 338 == 1
E        +  where 338 = <built-in method get of dict object at 0x7fe68d4df990>('message_id')
E        +    where <built-in method get of dict object at 0x7fe68d4df990> = {'is_pinned': False, 'message': 'Hello Guys', 'message_id': 338, 'reacts': [{'is_this_user_reacted': False, 'react_id': 1, 'u_ids': []}], ...}.get

http_tests/other_http_test.py:198: AssertionError
__________________________ test_search_invalid_token ___________________________

    def test_search_invalid_token():
    
        requests.delete(config.url + "clear/v1")
        temp = jwt.encode({"sessionId": 7}, database.secretSauce, algorithm = "HS256")
    
        # Search
        funcURL = "search/v2"
        inputData = {
            "token": temp,
            "query_str": "Hello",
        }
        qData = urllib.parse.urlencode(inputData)
        searchx = requests.get(config.url + funcURL + "?" + qData)
>       searchxR = json.loads(searchx.text)

http_tests/other_http_test.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.7/json/__init__.py:348: in loads
    return _default_decoder.decode(s)
/usr/lib/python3.7/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7fe68ecd4400>
s = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<title>403 Forbidden</title>\n<h1>Forbidden</h1>\n<p>Invalid token</p>\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/lib/python3.7/json/decoder.py:355: JSONDecodeError
________________________ test_http_user_profile_working ________________________

    def test_http_user_profile_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM0MSwibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6IjA2ZTJhMTIyLWI5YWEtNGNhMi1hNDZkLWRmODhmYzkxZDNmZCJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\x8d\x9c\x93\xc7\x95\xfcxI\x06\xc5\x1al>\xb9[\xfa\xce\xea`|\xd3\xa9\xba\xc7@443A%\xed/'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
__________________ test_http_user_profile_v2_nonexistant_user __________________

    def test_http_user_profile_v2_nonexistant_user():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM0MiwibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6Ijc5MmYwNmM3LTc3MTEtNDY5Zi04YThjLWVmOGEyYTUzMjcxMyJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xdd\xf1\x17\x89\xd1\xe3\xab\x85$\x0b23\xdcQ\xf3X\xbd\xfc\xe8\xe7\x95u\xa1V\n\x06hJ\xcf\xb7\xec\x81'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
______________________ test_user_profile_setname_working _______________________

    def test_user_profile_setname_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM0MywibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6ImE5YTJjZDYyLTQ0YTUtNGI4MC04MTFlLTdkMGIxMWI1YTIxMCJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b')\xaf\xd4\x88\x8b\xfcE^@w\xe4\xac-\xb0\xe2\x8f\r\x0f\xd0\x9e_\x84\x7f>\xc8O\n\nj"\x9f\x91'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
__________________ test_http_user_profile_setname_short_first __________________

    def test_http_user_profile_setname_short_first():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM0NCwibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6IjM2MmMyYWEzLWZjODAtNDdkZC05Y2E3LTIyYWI5NjgyNWM2YyJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\x7f!\xc9\xd7\xc8\xd4\x8e\xd6\xbe\xfc\x95\x06\xd2\x9cVd\x985\xd9A\x81.\xd7Td\x1d\x890q\xa2\x03e'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
__________________ test_http_user_profile_setname_short_last ___________________

    def test_http_user_profile_setname_short_last():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM0NSwibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6ImUyNmM5MWI4LTU1MjAtNDE3ZS1hZjRkLTczMWE4MTc4MDRiZiJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'(\tL\x8c\xf9\x08\xca{\xba\x87\xaaH\xbf\x14\xb1\xe6\x9a\n\xafK\x1c\xe1m\x99\x8d\x95\xf0$R\xa4\xe0p'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
__________________ test_http_user_profile_setname_long_first ___________________

    def test_http_user_profile_setname_long_first():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM0NiwibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6IjkxODM0ZTM4LTA4MzUtNGM4ZC05OTE1LTJkZjQzNGZkZmY5ZiJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xbc\xdd]\x8e\xfe3BP\xa7Z\x8bs\xc8\xfa\xafHz\xc8\xc3]3\r\xac\x19m\x92\xaa\xc7V\xce\x1eH'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
___________________ test_http_user_profile_setname_long_last ___________________

    def test_http_user_profile_setname_long_last():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:231: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM0NywibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6IjlhZTU5NDgzLTBmNmEtNDAyZi1iMTQwLWY1NTkxYWVlM2FhMiJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xe6\xeb\x80\xdb\xcf\xbf\xd1p4\x89\x0f\x00\x13`Y\x01)\xc3\xdbV\x9e\xd9\x03v(L\x9e\xa2r\xb6\xa5s'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
___________________ test_http_user_profile_setemail_working ____________________

    def test_http_user_profile_setemail_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM0OCwibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6ImMxM2FmYjU3LTM0NDktNDFiNi1hODM3LTVmNWRmNTkyNjY3OCJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'JM+\n\x85\x9fz\x19\x8a|\xad\xd3\x1a\x12\xae\xef\\\xd5\xd2\x18q\x9d\xe0\xf6\x03G\xc85\x93\xb3\xbf\x93'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
________________ test_http_user_profile_setemail_invalid_email _________________

    def test_http_user_profile_setemail_invalid_email():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM0OSwibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6IjVhYjZlYWRhLWI4NmEtNDkwOS05MDdmLWMxYjYzNGUxZDI0MSJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xe3\x8d\x0f\x17`\x0f\xda\xafT1\x02\xaf\x94)\xc1kn\x8c\x89\x81\xa4\x16\x9f\xf7\xe8\xd2nM<\xac\xbar'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
_________________ test_http_user_profile_setemail_email_taken __________________

    def test_http_user_profile_setemail_email_taken():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM1MCwibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6ImM1MWUyNDY3LWJiMzAtNGE2Ny1hNzY0LWMyYzc1YTY5MjI2MyJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xd4]\xaa;\\\xa0\x00=\t\xef4\x80\x0b\xc2g\xad\xb8\xc3\\h\xfdY?I\x88\x10T\x17X!\xff\xee'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
___________________ test_http_user_profile_sethandle_working ___________________

    def test_http_user_profile_sethandle_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:386: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM1MSwibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6IjEzNTc5MDIwLWI2MmItNDdjOC04Y2U4LTE5MWIzYzhhN2VlYiJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xfe\x19U\x98\xa6\x9a\xfc\x7f\xac\x9b\x18\xc37\n@@\x88\xc1\x00\xc9 W\xe1\x9d\x90g>\x03M~n\xe8'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
________________ test_http_user_profile_sethandle_short_handle _________________

    def test_http_user_profile_sethandle_short_handle():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM1MiwibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6IjYyMTQ4YTY5LTM1YmItNGY5ZC1hZWYwLTU3MjljYWU0YTM4MSJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xf0\r\xaeDpk\xa7\xdba5)\x01gd\x83\xe8\x9f\x94X\x93\x824\xda\x90\xe5\xc7\xa5\xb1\x91\x9c\xe7\xc9'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
_________________ test_http_user_profile_sethandle_long_handle _________________

    def test_http_user_profile_sethandle_long_handle():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:464: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM1MywibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6IjgyMDk1NDBiLTlmY2ItNDhmOS04Y2I4LTA2OTgwYTNiZDIxMSJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\xf6\xb1\xbc\xd1D\x94\xd9P\\U\x90n\xe3\x8erdG\xa1\x14-\x1d\x8c2D\xf0cR\xfd\xeb\xfatH'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
________________ test_http_user_profile_sethandle_handle_taken _________________

    def test_http_user_profile_sethandle_handle_taken():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        _ = requests.post(config.url + funcURL, json=inputData)
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password2",
            "name_first": "name2First",
            "name_last": "name2Last",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM1NSwibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6ImZmMTNjZWMyLTgwMTAtNDk2NC1hNDhhLTM5YmRhYzJiY2JhMCJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\x1d\xd04\xfb\xb2\x00\x8bC\xe9\x9e\x17W\xfb?[\xd6\xa4\xa8\xeb\xd1\x9a\x0c\xcb\xd4\xedR\xe5\xa4\xf9\x11"F'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
_________________________ test_http_users_all_working __________________________

    def test_http_users_all_working():
        requests.delete(config.url + "clear/v1")
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test@hotmail.com",
            "password": "password1",
            "name_first": "nameFirst",
            "name_last": "nameLast",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        u_id1 = respD["auth_user_id"]
        # ----------------------------
    
        # Register--------------------
        funcURL = "auth/register/v2"
        inputData = {
            "email": "test2@hotmail.com",
            "password": "password2",
            "name_first": "name2First",
            "name_last": "name2Last",
        }
        rawResponseData = requests.post(config.url + funcURL, json=inputData)
        respD = json.loads(rawResponseData.text)
        jwtToken = respD["token"]
>       _ = jwt.decode(jwtToken, database.secretSauce, algorithms="HS256")

http_tests/user_http_test.py:548: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:113: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jwt.py:88: in decode_complete
    **kwargs,
/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:149: in decode_complete
    self._verify_signature(signing_input, header, signature, key, algorithms)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7fe68e02d9e8>
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJnaWQiOjM1NywibG9naW5fdGltZSI6MTYxOTE4NjUxNiwic2FsdCI6IjM1NGM4NDMzLTRiYTktNGQ1Mi1iY2M1LTY0NzY2MzQ5ODQ0OCJ9'
header = {'alg': 'HS256', 'typ': 'JWT'}
signature = b'\x89\xf9\xee\xda_E\x15\xc0\xb7\xfaE\x13\xc6:\x1e\xce\xb6de\x88\x07\xd0\x07JV\xea\xb7\x0c\xe9\xff\xef\x9d'
key = b'placeholder', algorithms = 'HS256'

    def _verify_signature(
        self,
        signing_input,
        header,
        signature,
        key="",
        algorithms=None,
    ):
    
        alg = header.get("alg")
    
        if algorithms is not None and alg not in algorithms:
            raise InvalidAlgorithmError("The specified alg value is not allowed")
    
        try:
            alg_obj = self._algorithms[alg]
            key = alg_obj.prepare_key(key)
    
            if not alg_obj.verify(signing_input, key, signature):
>               raise InvalidSignatureError("Signature verification failed")
E               jwt.exceptions.InvalidSignatureError: Signature verification failed

/import/kamen/3/cs1531/.local/lib/python3.7/site-packages/jwt/api_jws.py:236: InvalidSignatureError
=========================== short test summary info ============================
FAILED http_tests/admin_http_test.py::test_http_admin_user_remove_u_id_does_not_exist
FAILED http_tests/admin_http_test.py::test_http_admin_user_remove_auth_not_owner
FAILED http_tests/admin_http_test.py::test_http_admin_user_remove_auth_only_owner
FAILED http_tests/admin_http_test.py::test_http_admin_userpermission_u_id_does_not_exist
FAILED http_tests/admin_http_test.py::test_http_admin_userpermission_permission_id_not_valid
FAILED http_tests/admin_http_test.py::test_http_admin_userpermission_auth_not_owner
FAILED http_tests/admin_http_test.py::test_http_admin_user_remove_u_id_does_not_exist
FAILED http_tests/admin_http_test.py::test_http_admin_user_remove_auth_not_owner
FAILED http_tests/admin_http_test.py::test_http_admin_user_remove_auth_only_owner
FAILED http_tests/admin_http_test.py::test_http_admin_userpermission_u_id_does_not_exist
FAILED http_tests/admin_http_test.py::test_http_admin_userpermission_permission_id_not_valid
FAILED http_tests/admin_http_test.py::test_http_admin_userpermission_auth_not_owner
FAILED http_tests/auth_http_test.py::test_http_auth_register_already_registered_email
FAILED http_tests/auth_http_test.py::test_http_auth_register_invalid_email - ...
FAILED http_tests/auth_http_test.py::test_http_auth_register_short_first - js...
FAILED http_tests/auth_http_test.py::test_http_auth_register_short_last - jso...
FAILED http_tests/auth_http_test.py::test_http_auth_register_long_first - jso...
FAILED http_tests/auth_http_test.py::test_http_auth_register_long_last - json...
FAILED http_tests/auth_http_test.py::test_http_auth_login_invalid_email - jso...
FAILED http_tests/auth_http_test.py::test_http_auth_login_unregistered_email
FAILED http_tests/auth_http_test.py::test_http_auth_login_incorrect_password
FAILED http_tests/auth_http_test.py::test_http_logout_working - jwt.exception...
FAILED http_tests/auth_http_test.py::test_http_logout_invalid_token_key - jso...
FAILED http_tests/auth_http_test.py::test_http_logout_invalid_token_value - j...
FAILED http_tests/auth_http_test.py::test_http_logout_invalid_token_type - js...
FAILED http_tests/auth_http_test.py::test_http_logout_nonexistant_user - json...
FAILED http_tests/channel_http_test.py::testjoin_invalid_channelID - json.dec...
FAILED http_tests/channel_http_test.py::testjoin_invalid_tokenn - json.decode...
FAILED http_tests/channel_http_test.py::testjoin_joined_already - json.decode...
FAILED http_tests/channel_http_test.py::testjoin_private_channel - json.decod...
FAILED http_tests/channel_http_test.py::testjoin_already_joined - json.decode...
FAILED http_tests/channel_http_test.py::testjoin_valid_case - AssertionError:...
FAILED http_tests/channel_http_test.py::testaddowner_invalid_tokenn - json.de...
FAILED http_tests/channel_http_test.py::testaddowner_invalid_uID - json.decod...
FAILED http_tests/channel_http_test.py::testaddowner_invalid_channelID - json...
FAILED http_tests/channel_http_test.py::testaddowner_already_owner - json.dec...
FAILED http_tests/channel_http_test.py::testaddowner_unauthorised_token - jso...
FAILED http_tests/channel_http_test.py::testaddowner_not_in_channel - KeyErro...
FAILED http_tests/channel_http_test.py::testaddowner_valid_case - AssertionEr...
FAILED http_tests/channel_http_test.py::test_http_channel_removeowner_invalid_user
FAILED http_tests/channel_http_test.py::test_http_channel_removeowner_invalid_channel
FAILED http_tests/channel_http_test.py::test_http_channel_removeowner_only_owner
FAILED http_tests/channel_http_test.py::test_http_channel_removeowner_not_owner
FAILED http_tests/channel_http_test.py::test_http_channel_removeowner_invalid_token
FAILED http_tests/channel_http_test.py::test_http_channel_leave_channel_valid
FAILED http_tests/channel_http_test.py::test_http_channel_leave_user_valid - ...
FAILED http_tests/channel_http_test.py::test_http_channel_messages_working - ...
FAILED http_tests/channel_http_test.py::test_http_channel_messages_invalid_channel
FAILED http_tests/channel_http_test.py::test_http_channel_messages_startgreater
FAILED http_tests/channel_http_test.py::test_http_channel_messages_not_authorised
FAILED http_tests/channels_http_test.py::test_http_channels_create_working - ...
FAILED http_tests/channels_http_test.py::test_http_channels_create_multiple
FAILED http_tests/channels_http_test.py::test_http_channels_create_invalid_token
FAILED http_tests/channels_http_test.py::test_http_channels_create_longer_than_twenty_char
FAILED http_tests/channels_http_test.py::test_http_channels_list_working - As...
FAILED http_tests/channels_http_test.py::test_http_channels_list_invalid_user
FAILED http_tests/channels_http_test.py::test_http_channels_listall_invalid_user
FAILED http_tests/dm_http_test.py::test_http_dm_create_working - json.decoder...
FAILED http_tests/dm_http_test.py::test_http_dm_create_invalid_user - json.de...
FAILED http_tests/dm_http_test.py::test_http_dm_create_invalid_token - json.d...
FAILED http_tests/dm_http_test.py::test_http_dm_invite_working - AssertionErr...
FAILED http_tests/dm_http_test.py::test_http_dm_invite_invalid_dmid - json.de...
FAILED http_tests/dm_http_test.py::test_http_dm_invite_invalid_uid - json.dec...
FAILED http_tests/dm_http_test.py::test_http_dm_inviter_not_in_dm - json.deco...
FAILED http_tests/dm_http_test.py::test_http_dm_list_working - AssertionError...
FAILED http_tests/dm_http_test.py::test_http_dm_list_invalid_token - json.dec...
FAILED http_tests/dm_http_test.py::test_http_dm_leave_working - json.decoder....
FAILED http_tests/dm_http_test.py::test_http_dm_leave_invalid_dm - json.decod...
FAILED http_tests/dm_http_test.py::test_http_dm_leave_unauthorized_user - jso...
FAILED http_tests/dm_http_test.py::test_http_dm_leave_invalid_token - json.de...
FAILED http_tests/dm_http_test.py::test_http_dm_remove_working - json.decoder...
FAILED http_tests/dm_http_test.py::test_http_dm_remove_invalid_id - json.deco...
FAILED http_tests/dm_http_test.py::test_http_dm_remove_not_owner - json.decod...
FAILED http_tests/dm_http_test.py::test_http_dm_remove_invalid_token - json.d...
FAILED http_tests/dm_http_test.py::test_http_dm_message_working - json.decode...
FAILED http_tests/dm_http_test.py::test_http_dm_message_invalid_user - json.d...
FAILED http_tests/dm_http_test.py::test_http_dm_message_invalid_dm - json.dec...
FAILED http_tests/dm_http_test.py::test_http_dm_message_unauthorised_user - j...
FAILED http_tests/dm_http_test.py::test_http_dm_message_startgreater - json.d...
FAILED http_tests/dm_http_test.py::test_http_dm_message_endnegativeone - json...
FAILED http_tests/dm_http_test.py::test_http_dm_details_dm_does_not_exist - j...
FAILED http_tests/dm_http_test.py::test_http_dm_details_user_not_member_of_dm
FAILED http_tests/dm_http_test.py::test_http_dm_details_valid - AssertionErro...
FAILED http_tests/echo_http_test.py::test_echo - json.decoder.JSONDecodeError...
FAILED http_tests/message_http_test.py::testsend_empty_message - KeyError: 'c...
FAILED http_tests/message_http_test.py::testsend_invalid_long_msg - json.deco...
FAILED http_tests/message_http_test.py::testsend_invalid_token - json.decoder...
FAILED http_tests/message_http_test.py::testsend_invalid_channel - json.decod...
FAILED http_tests/message_http_test.py::testsend_sent_not_in_channel - json.d...
FAILED http_tests/message_http_test.py::testsend_valid_case - assert 238 == 1
FAILED http_tests/message_http_test.py::testedit_empty - KeyError: 'code'
FAILED http_tests/message_http_test.py::testedit_invalid_long_msg - json.deco...
FAILED http_tests/message_http_test.py::testedit_invalid_token - json.decoder...
FAILED http_tests/message_http_test.py::testedit_invalid_mID - json.decoder.J...
FAILED http_tests/message_http_test.py::testedit_not_authorised - json.decode...
FAILED http_tests/message_http_test.py::testedit_valid_case - assert 257 == 1
FAILED http_tests/message_http_test.py::testedit_comprehensive_valid - assert...
FAILED http_tests/message_http_test.py::testremove_invalid_token_id - json.de...
FAILED http_tests/message_http_test.py::testremove_invalid_mID - json.decoder...
FAILED http_tests/message_http_test.py::testremove_empty - json.decoder.JSOND...
FAILED http_tests/message_http_test.py::testremove_unauthorised - json.decode...
FAILED http_tests/message_http_test.py::testsenddm_invalid_empty_message - Ke...
FAILED http_tests/message_http_test.py::testsenddm_invalid_long_msg - json.de...
FAILED http_tests/message_http_test.py::testsenddm_invalid_token_ID - json.de...
FAILED http_tests/message_http_test.py::testsenddm_invalid_dmID - json.decode...
FAILED http_tests/message_http_test.py::testsenddm_unauthorised_user - json.d...
FAILED http_tests/message_http_test.py::testsenddm_valid_case - assert 300 == 1
FAILED http_tests/message_http_test.py::test_http_message_share_not_member_of_channel_sharing_to
FAILED http_tests/message_http_test.py::test_http_message_share_not_member_of_dm_sharing_to
FAILED http_tests/other_http_test.py::test_http_clear_dm - json.decoder.JSOND...
FAILED http_tests/other_http_test.py::test_search_working - AssertionError: a...
FAILED http_tests/other_http_test.py::test_search_invalid_token - json.decode...
FAILED http_tests/user_http_test.py::test_http_user_profile_working - jwt.exc...
FAILED http_tests/user_http_test.py::test_http_user_profile_v2_nonexistant_user
FAILED http_tests/user_http_test.py::test_user_profile_setname_working - jwt....
FAILED http_tests/user_http_test.py::test_http_user_profile_setname_short_first
FAILED http_tests/user_http_test.py::test_http_user_profile_setname_short_last
FAILED http_tests/user_http_test.py::test_http_user_profile_setname_long_first
FAILED http_tests/user_http_test.py::test_http_user_profile_setname_long_last
FAILED http_tests/user_http_test.py::test_http_user_profile_setemail_working
FAILED http_tests/user_http_test.py::test_http_user_profile_setemail_invalid_email
FAILED http_tests/user_http_test.py::test_http_user_profile_setemail_email_taken
FAILED http_tests/user_http_test.py::test_http_user_profile_sethandle_working
FAILED http_tests/user_http_test.py::test_http_user_profile_sethandle_short_handle
FAILED http_tests/user_http_test.py::test_http_user_profile_sethandle_long_handle
FAILED http_tests/user_http_test.py::test_http_user_profile_sethandle_handle_taken
FAILED http_tests/user_http_test.py::test_http_users_all_working - jwt.except...
======================== 127 failed, 20 passed in 7.09s ========================
